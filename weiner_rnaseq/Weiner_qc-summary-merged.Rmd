---    
output:
  knitrBootstrap::bootstrap_document:
    theme: readable
    highlight: zenburn
    theme.chooser: TRUE
    highlight.chooser: TRUE
  html_document:
    toc: true
    highlight: zenburn
---
        
   
```{r setup0, echo=FALSE}
knitr::opts_chunk$set(tidy=TRUE, highlight=TRUE, dev="png",
                      cache=FALSE, highlight=TRUE, autodep=TRUE, warning=FALSE, error=FALSE,
                      message=FALSE, prompt=TRUE, comment='', fig.cap='', fig.height = 9, fig.width = 12, bootstrap.show.code=FALSE)
```

```{r projsetup, echo=FALSE, warning=FALSE, message=FALSE}
project="Weiner RNA-seq - merge all runs"
clientname="Dan Hu"
clientemail=""
labPI="Weiner"
analystname="Mary Piper"
analystemail="piper@hsph.harvard.edu"
```
---
        
# Weiner Quality Control Report
        
Quality control report for RNA-Seq on four types of CD4+ T cells (DP, Th17, Th1, DN) that were isolated from age, sex, and race-matched healthy human donors and patients, including data from only the first batch of samples. The CD4+ T cells were separated into the four cell types by levels of IL-17 and IFN-g using FACS. The hypothesis is that IL-17+/IFN-g+ (DP) cells are involved in inflammatory disorders, including MS.

Client: `r clientname`, `r labPI` group.  

Analysts: `r analystname` (`r analystemail`)

The most recent update of this html document occurred: `r date()`

---

# Overview
        
```{r qc-setup}
library(ggplot2)
library(reshape)
library(gplots)
library(edgeR)
library(CHBUtils)
library(pheatmap)
library(RColorBrewer)
library(knitr)
library(tidyr)
library(reshape)
library(rmarkdown)
library(dplyr)
library(ggdendro)
library(grid)
library(reshape)
library(gridExtra)
library(Biobase)
library(scales)
library(genefilter)
library(biomaRt)

#Brining in batch 1
sample_names1 <- c("S1-1", "S2-1", "S3-1", "S4-1", "S5-1", "S6-1", "S7-1", "S8-1", "S9-1", "S10-1", "S11-1", "S12-1", "S13-1", "S14-1", "S15-1", "S16-1", "S17-1", "S18-1", "S19-1", "S20-1", "S21-1", "S22-1", "S23-1", "S24-1")
project_summary1 = "~/Dropbox/HBC consults/2015_11_09_weiner/run1/project-summary_nobatch2.csv"
counts_file1 = "~/Dropbox/HBC consults/2015_11_09_weiner/run1/data/combined.counts_nobatch2.txt"
path_results1 = "~/Dropbox/HBC consults/2015_11_09_weiner/run1/report"
ann.genes1 <- read.table(file.path('~/Dropbox/HBC consults/2015_11_09_weiner/run1/data/annotated_combined.counts_nobatch2'), header=T, sep="\t", row.names=1, as.is=T)
colnames(ann.genes1) <- c(sample_names1,"symbol")
#ann.genes1 <- ann.genes1[,c(1:24,37)]
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
               "#0072B2", "#D55E00", "#CC79A7")
summarydata1 = data.frame(read.table(project_summary1, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata1$batch <- rep(1,24)
summarydata1$celltype <- c("DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","Th17", "DP", "Th1", "DN", "DP", "Th17", "Th1", "DN", "DP", "Th17", "Th1", "DN")
summarydata1$Name = rownames(summarydata1)
summarydata1 = summarydata1[order(summarydata1$Name),]
summarydata1 <- summarydata1[,c(1:25,28,31:33)]
rownames(summarydata1) <- sample_names1
counts1 = read.table(counts_file1, header=TRUE, row.names="id", check.names=FALSE)
counts1 = counts1[, order(colnames(counts1))]
colnames(counts1) <- sample_names1
total_counts1 <- colSums (counts1, na.rm = FALSE, dims = 1)
y = DGEList(counts=counts1)
y = calcNormFactors(y)
normalized_counts1 = cpm(y, normalized.lib.sizes=TRUE)
colnames(counts1) = gsub(".counts", "", colnames(counts1))
# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA_rate", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
meta1 = summarydata1[, !colnames(summarydata1) %in% known_columns, drop=FALSE]
metadata1 = subset(meta1, select=samplegroup)
metadata1$celltype <- c("DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","Th17", "DP", "Th1", "DN", "DP", "Th17", "Th1", "DN", "DP", "Th17", "Th1", "DN")
metadata1$disease <- c("patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy")
metadata1$batch <- rep(1, 24)

qc1 <- read.table(file.path(path_results1, "metrics", "metrics_nobatch2.tsv"),
                header=T, sep="\t", check.names=F,
                colClasses=list("sample"="character"))
rownames(qc1) = sample_names1
qc1$Mapped_reads_pct = as.numeric(gsub("%", "", qc1$Mapped_reads_pct))
qc1$Duplicates_pct = as.numeric(gsub("%", "", qc1$Duplicates_pct))

#Bringing in batch 2
sample_names2 <- c("S1-2", "S2-2", "S3-2", "S4-2", "S5-2", "S6-2", "S7-2", "S8-2", "S9-2", "S10-2", "S11-2", "S12-2", "S13-2", "S14-2", "S15-2", "S16-2", "S17-2", "S18-2", "S19-2", "S20-2", "S21-2", "S22-2", "S23-2", "S24-2")
project_summary2 = "~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq2/project-summary2.csv"
counts_file2 = "~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq2/combined.counts2"
path_results2 = "~/Dropbox/HBC consults/2015-11-09_weiner/run2/2015-12-13_weiner-rnaseq2/report"
ann.genes2 <- read.table(file.path("~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq2/annotated_combined.counts2"), header=T, sep="\t", row.names=1, as.is=T)
colnames(ann.genes2) <- c(sample_names2, "symbol")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
               "#0072B2", "#D55E00", "#CC79A7")
summarydata2 = data.frame(read.table(project_summary2, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata2$Name = rownames(summarydata2)
summarydata2 = summarydata2[order(summarydata2$Name),]
rownames(summarydata2) <- sample_names2
counts2 = read.table(counts_file2, header=TRUE, row.names="id", check.names=FALSE)
counts2 = counts2[, order(colnames(counts2))]
colnames(counts2) <- sample_names2
total_counts2 <- colSums (counts2, na.rm = FALSE, dims = 1)
y = DGEList(counts=counts2)
y = calcNormFactors(y)
normalized_counts2 = cpm(y, normalized.lib.sizes=TRUE)
colnames(counts2) = gsub(".counts", "", colnames(counts2))
# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA_rate", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
meta2 = summarydata2[, !colnames(summarydata2) %in% known_columns, drop=FALSE]
metadata2 = subset(meta2, select=samplegroup)
metadata2$celltype <- c("DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","Th17", "DP", "Th1", "DN", "DP", "Th17", "Th1", "DN", "DP", "Th17", "Th1", "DN")
metadata2$disease <- c("patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy")
metadata2$batch <- rep(2, 24)

qc2 <- read.table("~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq2/report/metrics/metrics.tsv", header=T, sep="\t", check.names=F)
rownames(qc2) = sample_names2
qc2$Mapped_reads_pct = as.numeric(gsub("%", "", qc2$Mapped_reads_pct))
qc2$Duplicates_pct = as.numeric(gsub("%", "", qc2$Duplicates_pct))

#Bringing in batch 3
sample_names3 <- c("S1-3", "S2-3", "S3-3", "S4-3", "S5-3", "S6-3", "S7-3", "S8-3", "S9-3", "S10-3", "S11-3", "S12-3", "S13-3", "S14-3", "S15-3", "S16-3", "S17-3", "S18-3", "S19-3", "S20-3", "S21-3", "S22-3", "S23-3", "S24-3")
project_summary3 = "~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq3/project-summary3.csv"
counts_file3 = "~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq3/combined.counts3"
path_results3 = "~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq3/report/"
ann.genes3 <- read.table(file.path("~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq3/annotated_combined.counts3"), header=T, sep="\t", row.names=1, as.is=T)
colnames(ann.genes3) = c(sample_names3, "symbol")
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
               "#0072B2", "#D55E00", "#CC79A7")
summarydata3 = data.frame(read.table(project_summary3, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata3$Name = rownames(summarydata3)
summarydata3 = summarydata3[order(summarydata3$Name),]
rownames(summarydata3) <- sample_names3
counts3 = read.table(counts_file3, header=TRUE, row.names="id", check.names=FALSE)
counts3 = counts3[, order(colnames(counts3))]
colnames(counts3) <- sample_names3
total_counts3 <- colSums (counts3, na.rm = FALSE, dims = 1)
y = DGEList(counts=counts3)
y = calcNormFactors(y)
normalized_counts3 = cpm(y, normalized.lib.sizes=TRUE)
colnames(counts3) = gsub(".counts", "", colnames(counts3))
# this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA_rate", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
meta3 = summarydata3[, !colnames(summarydata3) %in% known_columns, drop=FALSE]
metadata3 = subset(meta3, select=samplegroup)
metadata3$celltype <- c("DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","Th17", "DP", "Th1", "DN", "DP", "Th17", "Th1", "DN", "DP", "Th17", "Th1", "DN")
metadata3$disease <- c("patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy")
metadata3$batch <- rep(3, 24)
qc3 <- read.table("~/Dropbox/HBC consults/2015_11_09_weiner/run2/2015-12-13_weiner-rnaseq3/report/metrics/metrics.tsv", header=T, sep="\t", check.names=F)
rownames(qc3) = sample_names3
qc3$Mapped_reads_pct = as.numeric(gsub("%", "", qc3$Mapped_reads_pct))
qc3$Duplicates_pct = as.numeric(gsub("%", "", qc3$Duplicates_pct))


#Merging all batches for analysis
counts_merged <- cbind(counts1, counts2, counts3)
metadata_merged <- rbind(metadata1, metadata2, metadata3)
colnames(counts_merged) <- rownames(metadata_merged)
summarydata_merged <- rbind(summarydata1, summarydata2, summarydata3)
qc_merged <- rbind(qc1, qc2, qc3)

```

```{r heatmap-function}
get_heatmap_fn = function(summarydata_merged) {
        # return the pheatmap function with or without metadata   
        if(ncol(metadata_merged) == 0) {
                return(pheatmap)
        }
        else {
                # rownames(metadata) = summarydata$Name
                heatmap_fn = function(data, ...) {
                        pheatmap(data, annotation=metadata_merged, ...)
                }
                return(heatmap_fn)
        }}
heatmap_fn = get_heatmap_fn(summarydata_merged)
```

# Quality control metrics

```{r table, results='asis'}
metrics = c("sample", "Total_reads" ,"Mapped_reads_pct", "Duplicates_pct",
            "offtarget",
            "%GC", "Sequence_length", "Median_insert_size")
```

## Total reads
The total reads are the number of input reads in each sample. The number of reads for each sample varies greatly (between <5 million to >15 million). Not unexpected due to the low amount of starting RNA.

```{r total-reads}
ggplot(qc_merged, aes(x=rownames(qc_merged), y=Total_reads/1e6)) +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        geom_bar(stat = 'identity') +
        ylab("Million reads")
```

## Mapped reads
The number of mapped reads is low across samples (~5-10 million reads per sample), due to the low number of input reads.

```{r mapped-plot}

ggplot(summarydata_merged, aes(x=rownames(summarydata_merged), y=Mapped/1e6)) +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        geom_bar(stat="identity") +
        ylab("Million mapped reads") + xlab("")
```

## Genomic mapping rate
The genomic mapping rate represents the percentage of reads mapping to the reference genome. Low mapping rates are indicative of sample contamination, poor sequencing quality or other artifacts.

The percent of input reads mapped is generally good (80-90%) for all of samples.

```{r mapping-rate-plot}
ggplot(summarydata_merged, aes(x=rownames(summarydata_merged), y=Mapping.Rate)) +
        geom_bar(stat="identity") +
        ylab("mapping rate (mapped_reads/total_reads") + xlab("") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90))
```

## Unique mapping rate
A low unique mapping rate, ~20% of the reads mapping to unique locations on the genome. High rates of duplication were identified during QC. Also, the low unique mapping rate indicates the library is of low complexity, which is not surprising due to the low number of input reads.

```{r unique-rate-plot}
dd = data.frame(Name=names(counts_merged), Unique=colSums(counts_merged), Mapped=summarydata_merged[,"Mapped"])
ggplot(dd, aes(x=Name, y=Unique/Mapped)) +
        geom_bar(stat="identity") +
        ylab("unique mapping rate") + xlab("") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90))
```

## Number of genes detected
Low number of genes detected (~10,000) for each sample, with extremely low numbers (< 5,000) for some samples. Expect ~20,000 genes detected for human samples. Again, likely due to the low complexity of the library and high amounts of rRNA and mitochondrial genes.

```{r genes-detected-plot}
dd = data.frame(Name=names(counts_merged), Genes.Detected = colSums(counts_merged > 0))
ggplot(dd, aes(x=Name, y=Genes.Detected)) +
        geom_bar(stat="identity") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        ylab("genes detected") + xlab("")
```

## Gene detection saturation
Samples vary substantially in number of genes detected based on the number of reads mapped. Could be due to a high degree of rRNA or mitochondrial RNA. Also, number of genes detected hasn't reached saturation. Please see the following thread regarding similar issues using the Ovation® RNA-Seq System V2: [http://seqanswers.com/forums/showthread.php?t=12373](http://seqanswers.com/forums/showthread.php?t=12373).

```{r saturation-plot}
dd = data.frame(Mapped=summarydata_merged$Mapped, Genes.Detected = colSums(counts_merged > 0))
ggplot(dd, aes(x=Mapped, y=Genes.Detected)) +
geom_point() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) +
ylab("genes detected") + xlab("reads mapped")
```

## Exonic mapping rate
Most samples have exonic mapping rates of between 30-50%. A good exonic mapping rate is generally between 70-80%.
```{r exonic-mapping-plot}
ggplot(summarydata_merged, aes(x=rownames(summarydata_merged), y=Exonic.Rate)) +
geom_bar(stat="identity") +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) +
ylab("exonic mapping rate") + xlab("")
```

## rRNA mapping rate
The rRNA mapping rate is very high, generally between 30-40% of mapped reads. 

```{r rRNA-rate-plot}
ggplot(summarydata_merged, aes(x=rownames(summarydata_merged), y=rRNA_rate)) +
geom_bar(stat="identity") +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) +
ylab("rRNA rate") + xlab("")
```

## Estimated fragment length of paired-end reads
```{r fragment-length-plot}
ggplot(summarydata_merged, aes(x=rownames(summarydata_merged), y=Fragment.Length.Mean)) +
geom_bar(stat="identity") +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) +
ylab("fragment length") + xlab("")
```

## Boxplot of log10 counts per gene
This plot shows some variation between samples for the general spread of the data, but not bad.
```{r boxplot-raw}
melted = melt(counts_merged)
colnames(melted) = c("sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) + xlab("")
```

## Boxplot of log10 TMM-normalized counts per gene
The spread of the log10 TMM-normalized counts per gene data should be similar for every sample. Optimal data would display similar boxplots for each sample without many outliers. 

This plot shows some variation between samples for the general spread of the data, but not bad. S13 sample is a bit of an outlier.

Trimmed mean of M-values (TMM) normalization is described
[here](http://genomebiology.com/2010/11/3/R25)

Robinson, M. D., & Oshlack, A. (2010). A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology, 11(3). doi:10.1186/gb-2010-11-3-r25

```{r boxplot-normalized}
y = DGEList(counts=counts_merged)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
melted = melt(normalized_counts)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) + xlab("")

```

## Density of log10 TMM-normalized counts
Density of normalized counts per gene should be very similar between samples, with no large shifts in any of the sample curves.

Our data shows a great degree of variation between samples for all genes, which may skew the differential expression results. Generally, these curves are similar, with a single large outlier.

```{r density-normalized}
ggplot(melted, aes(x=count, group=sample)) +
geom_density() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) + xlab("")
```

## Correlation (Pearson) heatmap of TMM-normalized counts
Correlation between samples of the same group is not good. There is very little clustering within cell types.
```{r pearson-heatmap-normalized}
heatmap_fn(cor(normalized_counts, method="pearson"))
```

## Correlation (Spearman) heatmap of TMM-normalized counts
The Spearman correlation heatmap is more resistant to outliers than the Pearson heatmap (above), but again, the groups do not cluster well.
```{r spearman-heatmap-normalized}
heatmap_fn(cor(normalized_counts, method="spearman"))
```

## PCA plot of TMM-normalized counts
Principal components analysis is a multivariate technique that allows us to summarize the systematic patterns of variations in the data. PCA takes the expression levels for genes and transforms it in principal component space, reducing each sample into one point. Thereby, we can separate samples by expression variation, and identify potential sample outliers. The PCA plot is another way to look at how samples are clustering. 

In this PCA plot the groups do not cluster well.
```{r pca}
metadata_merged$name <- row.names(metadata_merged)

pca_matrix <- prcomp(t(normalized_counts))$x
df <- cbind(metadata_merged, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
0.3)) + ggtitle("PC1 vs PC2 :: normalized counts")
```


## Heatmap of top 30 most expressed genes
Many of the top expressers are mitochondrial genes, which is not surprising due to the earlier identification of mitochondrial RNA as being overexpressed in some samples during the QC. Very little clustering by sample group for these top expressing genes likely because the amount of ribosomal and mitochondrial RNA present was due to lab technique, not based on the sample.
```{r top-count-genes, results='asis'}
metadata_merged <- metadata_merged[,1:2]
select = order(rowMeans(counts_merged),decreasing=TRUE)[1:30]
heatmap_fn(counts_merged[select,])
```

## Heatmap by concordance correlation coefficient
Similarly, no clustering of samples
http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004075

```{r propcor-heatmap}
propcor = function(x, y) {
x = log(x + 0.1)
y = log(y + 0.1)
num = 2 * cov(x, y)
denom = var(x) + var(y)
return(num/denom)}

do_propcor = function(x) {
mat = list()
for(i in seq_len(ncol(x))) {
for(j in seq_len(ncol(x))) {
x2 = x[, i]
y2 = x[, j]
mat = c(mat, propcor(x2, y2)) } }
mat = unlist(mat)
mat = matrix(mat, ncol(x), ncol(x))
colnames(mat) = colnames(x)
rownames(mat) = colnames(x)
return(mat)}

heatmap_fn(do_propcor(normalized_counts))
```

#Analysis without rRNA and mitochondrial (mt) genes 
Due to the high levels of reads aligning to rRNA and mt genes, clustering analysis was performed after removal of count data for these genes. Reads aligning to the mitochondrial and rRNA genes account for over 20 million of the reads aligning to exons in the dataset, with each sample having, on average, between 400,000 and 700,000 reads out of total counts between 700,000 - 1,500,000. If only rRNA genes were filtered out, there would still be mitochondrial genes in the top 30 expressed genes. Therefore, mitochondrial and rRNA genes were filtered out, although the overexpressed rRNA genes are expressed from mitochondrial DNA.

```{r no rrna_marker_counts}
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
conversions = getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),
mart=human)
rrna_biotypes = c("rRNA", "Mt_rRNA", "misc_RNA", "snRNA", "snoRNA",
"tRNA", "Mt_tRNA")

rrna_genes <- unique(subset(conversions, gene_biotype %in% rrna_biotypes)$ensembl_gene_id)

mt_genes <- c("ENSG00000210049","ENSG00000211459","ENSG00000210077","ENSG00000210082","ENSG00000209082","ENSG00000198888","ENSG00000210100","ENSG00000210107","ENSG00000210112","ENSG00000198763","ENSG00000210117","ENSG00000210127","ENSG00000210135","ENSG00000210140","ENSG00000210144","ENSG00000198804","ENSG00000210151","ENSG00000210154","ENSG00000198712","ENSG00000210156","ENSG00000228253","ENSG00000198899","ENSG00000198938","ENSG00000210164","ENSG00000198840","ENSG00000210174","ENSG00000212907","ENSG00000198886","ENSG00000210176","ENSG00000210184","ENSG00000210191","ENSG00000198786","ENSG00000198695","ENSG00000210194","ENSG00000198727","ENSG00000210195","ENSG00000210196")

#Protein coding genes
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
protein_coding <- getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),filters = "biotype", values="protein_coding",mart=human)
pc_genes <- protein_coding[,1]

counts_pc_genes <- counts_merged[rownames(counts_merged) %in% pc_genes,]
sum_pc_genes <- colSums(counts_pc_genes, na.rm = FALSE, dims = 1)

#Reads aligning to mt genes
counts_mt_genes <- counts_merged[rownames(counts_merged) %in% mt_genes,]
sum_mt_genes <- colSums(counts_mt_genes, na.rm = FALSE, dims = 1)
#sum(sum_mt_genes)
#Reads aligning to rRNA genes
counts_rrna_genes <- counts_merged[rownames(counts_merged) %in% rrna_genes,]
sum_rrna_genes <- colSums(counts_rrna_genes, na.rm = FALSE, dims = 1)
#sum(sum_rrna_genes)

#Counts rrna genes not in mt genes
counts_gen_rrna <- counts_rrna_genes[!rownames(counts_rrna_genes) %in% mt_genes,]
sum_gen_rrna_genes <- colSums(counts_gen_rrna, na.rm = FALSE, dims = 1)
#Counts rrna genes in mt genes
counts_mt_rrna <- counts_rrna_genes[rownames(counts_rrna_genes) %in% mt_genes,]
sum_mt_rrna_genes <- colSums(counts_mt_rrna, na.rm = FALSE, dims = 1)
```

```{r no rrna_marker_heatmap}
#Analysis without mt and rRNA genes
norm_counts_no_rrna <- normalized_counts[!rownames(normalized_counts) %in% rrna_genes & !rownames(normalized_counts) %in% mt_genes,]

metadata_merged$name <- row.names(metadata)
metadata$celltype <- c("DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","DP", "Th17", "Th1", "DN","Th17", "DP", "Th1", "DN", "DP", "Th17", "Th1", "DN", "DP", "Th17", "Th1", "DN")
metadata_merged$disease <- c("patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy", "patient", "patient", "patient", "patient", "healthy", "healthy", "healthy", "healthy")
metadata_merged$pair <- c(1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3)


## Heatmap of marker genes
```{r Heatmap of markers}
counts_no_rrna_merged = counts_merged[!rownames(counts_merged) %in% rrna_genes & !rownames(counts_merged) %in% mt_genes,]
y = DGEList(counts=counts_no_rrna_merged)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
ann.norm.counts <- merge(normalized_counts, ann.genes1, by=0)
row.names(ann.norm.counts) <- ann.norm.counts$Row.names
ann.norm.counts <- ann.norm.counts[,c(2:73,98)]
ann_norm_counts_no_rrna = ann.norm.counts[!rownames(ann.norm.counts) %in% rrna_genes & !rownames(ann.norm.counts) %in% mt_genes,]

marker_norm_counts <- subset(ann_norm_counts_no_rrna, symbol == "IFNG" | symbol == "IL17A")
marker_norm_counts <- marker_norm_counts[1:72]
colnames(marker_norm_counts) <- rownames(summarydata_merged)
heatmap_fn(cor(marker_norm_counts, method="spearman"))
heatmap_fn((marker_norm_counts))
```

###PCA plot - no rrna or mitochondrial genes
Its hard to determine whether the groups cluster well by PCA plot - there doesn't seem to be a lot of variation between samples, perhaps because a large number of counts were used on the rRNA and mt genes.
```{r no rrna_PCA}
mds(norm_counts_no_rrna, k=length(colnames(norm_counts_no_rrna)) - 1)

pca_matrix <- prcomp(t(norm_counts_no_rrna))$x
df <- cbind(metadata_merged, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")
```

## Correlation (Spearman) heatmap of TMM-normalized counts - no rrna or mitochondrial genes
The Spearman correlation heatmap is more resistant to outliers than the Pearson heatmap (above), but again, the groups do not cluster well.
```{r no rrna_heatmap}
heatmap_fn(cor(norm_counts_no_rrna, method="spearman"))
```

##PCA of the top 500 variant genes
```{r no rrna_top 500 variant genes-PCA}
ntop <- 500
rv <- rowVars(norm_counts_no_rrna)
select <- order(rv, decreasing=TRUE)[seq_len(ntop)]
pca <- prcomp(t(norm_counts_no_rrna[select,]))
pca_cut <- pca[["x"]]
pca_cut <- pca_cut[,1:2]
df <- cbind(metadata_merged, pca_cut[,c("PC1","PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: 500 top variable genes (no rrna)")
```

##Analysis of Genes in Genelist (15 genes)
Overall, the samples cluster better in the PCA plot and heatmap.

###Analysis of Genes in Genelist (15 genes) - PCA
```{r genelist_setup_merged}
ann.genes <- cbind(ann.genes1[1:24], ann.genes2[1:24], ann.genes3)
y = DGEList(counts=counts_no_rrna_merged)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
ann.norm.counts <- merge(normalized_counts, ann.genes, by=0)
row.names(ann.norm.counts) <- ann.norm.counts$Row.names
ann.norm.counts <- ann.norm.counts[,c(2:73,146)]
colnames(ann.norm.counts) <- c(colnames(counts_merged), "symbol")
ann_norm_counts_no_rrna = ann.norm.counts[!rownames(ann.norm.counts) %in% rrna_genes & !rownames(ann.norm.counts) %in% mt_genes,]

ccl3 <- subset(ann_norm_counts_no_rrna, symbol == "CCL3")
ccl4 <- subset(ann_norm_counts_no_rrna, symbol == "CCL4")
ccl5 <- subset(ann_norm_counts_no_rrna, symbol == "CCL5")
ccl6 <- subset(ann_norm_counts_no_rrna, symbol == "CSF2")
ccl7 <- subset(ann_norm_counts_no_rrna, symbol == "CXCR3")
ccl8 <- subset(ann_norm_counts_no_rrna, symbol == "EPSTI1")
ccl9 <- subset(ann_norm_counts_no_rrna, symbol == "GZMB")
ccl10 <- subset(ann_norm_counts_no_rrna, symbol == "IFNG")
ccl11<- subset(ann_norm_counts_no_rrna, symbol == "IL23R")
ccl12<- subset(ann_norm_counts_no_rrna, symbol == "STAT3")
ccl13<- subset(ann_norm_counts_no_rrna, symbol == "IL3")
ccl14<- subset(ann_norm_counts_no_rrna, symbol == "RGS2")
ccl15 <- subset(ann_norm_counts_no_rrna, symbol == "STAT1")
ccl16<- subset(ann_norm_counts_no_rrna, symbol == "STAT5A")
ccl17<- subset(ann_norm_counts_no_rrna, symbol == "TBX21")
genes <- data.frame()
genes <- rbind(ccl3, ccl4, ccl5, ccl6, ccl7, ccl8, ccl9, ccl10, ccl11, ccl12, ccl13, ccl14, ccl15, ccl16, ccl17)
row.names(genes) <- genes$symbol
genes <- genes[,1:72]

#PCA plot of 15 genes
pca_matrix <- prcomp(t(genes))$x
df <- cbind(metadata_merged, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3,0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")   
```

###Analysis of Genes in Genelist (15 genes) - Heatmap
Some clustering by disease and celltype.
```{r top15_heatmap}
heatmap_fn(cor(genes, method="spearman"))
write.table(genes, file ="normalized_counts_15_genes_merged.txt", quote = FALSE, sep = "\t", row.names=T)

#Raw counts table
ann.genes <- cbind(ann.genes1, ann.genes2[1:24], ann.genes3[1:24])
ccl3 <- subset(ann.genes, symbol == "CCL3")
ccl4 <- subset(ann.genes, symbol == "CCL4")
ccl5 <- subset(ann.genes, symbol == "CCL5")
ccl6 <- subset(ann.genes, symbol == "CSF2")
ccl7 <- subset(ann.genes, symbol == "CXCR3")
ccl8 <- subset(ann.genes, symbol == "EPSTI1")
ccl9 <- subset(ann.genes, symbol == "GZMB")
ccl10 <- subset(ann.genes, symbol == "IFNG")
ccl11<- subset(ann.genes, symbol == "IL23R")
ccl12<- subset(ann.genes, symbol == "STAT3")
ccl13<- subset(ann.genes, symbol == "IL3")
ccl14<- subset(ann.genes, symbol == "RGS2")
ccl15 <- subset(ann.genes, symbol == "STAT1")
ccl16<- subset(ann.genes, symbol == "STAT5A")
ccl17<- subset(ann.genes, symbol == "TBX21")
counts_15_genes <- rbind(ccl3, ccl4, ccl5, ccl6, ccl7, ccl8, ccl9, ccl10, ccl11, ccl12, ccl13, ccl14, ccl15, ccl16, ccl17)
row.names(counts_15_genes) <- counts_15_genes$symbol
counts_15_genes <- counts_15_genes[, c(1:24, 26:73)]
#write.table(counts_15_genes, file ="raw_counts_15_genes.txt", quote = FALSE, sep = "\t", row.names=F)
```

#Combined results from all batches
```{r setup_combined}
combined_all_counts <- counts1 + counts2 + counts3
combined_ann_genes <- ann.genes1[1:24] + ann.genes2[1:24] + ann.genes3[1:24]
combined_ann_genes <- cbind(combined_ann_genes, ann.genes1$symbol)
colnames(combined_all_counts) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24")
colnames(combined_ann_genes) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24", "symbol")
combined_metadata <- metadata2
combined_metadata <- combined_metadata[1:3]
rownames(combined_metadata) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24")
combined_metadata$pair <- c(rep(seq(1:3), each = 8))
rownames(qc1) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24")
rownames(qc2) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24")
rownames(qc3) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24")
combined_qc <- qc1[,c(1:16, 20:24)] + qc2[,c(1:16, 20:24)] + qc3[,c(1:16, 20:24)]
combined_qc <- cbind(combined_qc, qc2[,c(17:19, 25:26)])
combined_summarydata <- summarydata1[, c(3:5, 15:16)] + summarydata2[, c(3:5, 15:16)] + summarydata3[, c(3:5, 15:16)]
combined_summarydata <- cbind(combined_summarydata, summarydata2[,c(25:27,29)])
rownames(combined_summarydata) <- c("S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "S14", "S15", "S16", "S17", "S18", "S19", "S20", "S21", "S22", "S23", "S24")
                     
```

```{r heatmap-function_combined}
get_heatmap_fn = function(combined_metadata) {
        # return the pheatmap function with or without metadata   
        if(ncol(combined_metadata) == 0) {
                return(pheatmap)
        }
        else {
                # rownames(metadata) = summarydata$Name
                heatmap_fn = function(data, ...) {
                        pheatmap(data, annotation=combined_metadata, ...)
                }
                return(heatmap_fn)
        }}
heatmap_fn = get_heatmap_fn(combined_metadata)
```

# Quality control metrics

```{r qc_setup_combined}
metrics = c("sample", "Total_reads" ,"Mapped_reads_pct", "Duplicates_pct",
            "offtarget","%GC", "Sequence_length", "Median_insert_size")
```


#Analysis without rRNA and mitochondrial (mt) genes 
Due to the high levels of reads aligning to rRNA and mt genes, clustering analysis was performed after removal of count data for these genes. Reads aligning to the mitochondrial and rRNA genes account for over 20 million of the reads aligning to exons in the dataset, with each sample having, on average, between 400,000 and 700,000 reads out of total counts between 700,000 - 1,500,000. If only rRNA genes were filtered out, there would still be mitochondrial genes in the top 30 expressed genes. Therefore, mitochondrial and rRNA genes were filtered out, although the overexpressed rRNA genes are expressed from mitochondrial DNA.

```{r no rrna_marker_counts_combined}
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
conversions = getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),
mart=human)
rrna_biotypes = c("rRNA", "Mt_rRNA", "misc_RNA", "snRNA", "snoRNA",
"tRNA", "Mt_tRNA")

rrna_genes <- unique(subset(conversions, gene_biotype %in% rrna_biotypes)$ensembl_gene_id)

mt_genes <- c("ENSG00000210049","ENSG00000211459","ENSG00000210077","ENSG00000210082","ENSG00000209082","ENSG00000198888","ENSG00000210100","ENSG00000210107","ENSG00000210112","ENSG00000198763","ENSG00000210117","ENSG00000210127","ENSG00000210135","ENSG00000210140","ENSG00000210144","ENSG00000198804","ENSG00000210151","ENSG00000210154","ENSG00000198712","ENSG00000210156","ENSG00000228253","ENSG00000198899","ENSG00000198938","ENSG00000210164","ENSG00000198840","ENSG00000210174","ENSG00000212907","ENSG00000198886","ENSG00000210176","ENSG00000210184","ENSG00000210191","ENSG00000198786","ENSG00000198695","ENSG00000210194","ENSG00000198727","ENSG00000210195","ENSG00000210196")

#Protein coding genes
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
protein_coding <- getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),filters = "biotype", values="protein_coding",mart=human)
pc_genes <- protein_coding[,1]

counts_pc_genes <- combined_all_counts[rownames(combined_all_counts) %in% pc_genes,]
sum_pc_genes <- colSums(counts_pc_genes, na.rm = FALSE, dims = 1)

#Reads aligning to mt genes
counts_mt_genes <- combined_all_counts[rownames(combined_all_counts) %in% mt_genes,]
sum_mt_genes <- colSums(counts_mt_genes, na.rm = FALSE, dims = 1)
#sum(sum_mt_genes)
#Reads aligning to rRNA genes
counts_rrna_genes <- combined_all_counts[rownames(combined_all_counts) %in% rrna_genes,]
sum_rrna_genes <- colSums(counts_rrna_genes, na.rm = FALSE, dims = 1)
#sum(sum_rrna_genes)
```

## Boxplot of log10 TMM-normalized counts per gene
The spread of the log10 TMM-normalized counts per gene data should be similar for every sample. Optimal data would display similar boxplots for each sample without many outliers. 

This plot shows some variation between samples for the general spread of the data, but not bad. S13 sample is a bit of an outlier.

Trimmed mean of M-values (TMM) normalization is described
[here](http://genomebiology.com/2010/11/3/R25)

Robinson, M. D., & Oshlack, A. (2010). A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology, 11(3). doi:10.1186/gb-2010-11-3-r25

```{r counts_density_combined}
#Analysis without mt and rRNA genes
```{r Heatmap of markers_combined}
combined_counts_no_rrna = combined_all_counts[!rownames(combined_all_counts) %in% rrna_genes & !rownames(combined_all_counts) %in% mt_genes,]
y = DGEList(counts=combined_counts_no_rrna)
y = calcNormFactors(y)
normalized_combined_counts_no_rrna = cpm(y, normalized.lib.sizes=TRUE)
ann.norm.counts <- merge(normalized_combined_counts_no_rrna, ann.genes1, by=0)
row.names(ann.norm.counts) <- ann.norm.counts$Row.names
ann.norm.counts <- ann.norm.counts[,c(2:25,50)]
ann_norm_counts_no_rrna <- ann.norm.counts[!rownames(ann.norm.counts) %in% rrna_genes & !rownames(ann.norm.counts) %in% mt_genes,]
#normalized_combined_counts_no_rrna <- normalized_combined_counts_no_rrna[,c(1:12, 14:24)]

melted = melt(normalized_combined_counts_no_rrna)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) + xlab("")
```

## Density of log10 TMM-normalized counts
Density of normalized counts per gene should be very similar between samples, with no large shifts in any of the sample curves.

Our data shows a great degree of variation between samples for all genes, which may skew the differential expression results. Generally, these curves are similar, with a single large outlier.

```{r density-normalized-combined}
ggplot(melted, aes(x=count, group=sample)) +
geom_density() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) + xlab("")
```

## Density of log10 TMM-normalized counts - no sample 13 (HTh17)
Density of normalized counts per gene should be very similar between samples, with no large shifts in any of the sample curves.

Our data shows a great degree of variation between samples for all genes, which may skew the differential expression results. Generally, these curves are similar, with a single large outlier.

```{r density-normalized}
normalized_combined_counts_no_rrna <- normalized_combined_counts_no_rrna[,c(1:12, 14:24)]

melted = melt(normalized_combined_counts_no_rrna)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=count, group=sample)) +
geom_density() +
theme_bw(base_size=10) +
theme(panel.grid.major = element_line(size = .5, color = "grey"),
axis.text.x = element_text(angle=90)) + xlab("")
```

## Heatmap of marker genes
```{r Heatmap of markers_combined}
marker_norm_counts <- subset(ann_norm_counts_no_rrna, symbol == "IFNG" | symbol == "IL17A")
marker_norm_counts <- marker_norm_counts[1:24]
colnames(marker_norm_counts) <- rownames(combined_summarydata)
heatmap_fn(cor(marker_norm_counts, method="spearman"))
heatmap_fn((marker_norm_counts))
```

###PCA plot (no mt genes) - by cell type
Its hard to determine whether the groups cluster well by PCA plot - there doesn't seem to be a lot of variation between samples, perhaps because a large number of counts were used on the rRNA and mt genes.

#### Cell type: DP
```{r no rrna_PCA_combined_DP}
DP_meta <- subset(combined_metadata, celltype == "DP")
DP_norm_counts <- normalized_combined_counts_no_rrna[, row.names(DP_meta)]
  
pca_matrix <- prcomp(t(DP_norm_counts))$x
df <- cbind(DP_meta, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")
```

#### Cell type: Th17
```{r no rrna_PCA_combined_Th17}
#combined_metadata <-combined_metadata[c(1:12,14:24),]  
Th17_meta <- subset(combined_metadata, celltype == "Th17")
Th17_norm_counts <- normalized_combined_counts_no_rrna[, row.names(Th17_meta)]

pca_matrix <- prcomp(t(Th17_norm_counts))$x
df <- cbind(Th17_meta, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")
```

#### Cell type: Th1
```{r no rrna_PCA_combined_Th1}
Th1_meta <- subset(combined_metadata, celltype == "Th1")
Th1_norm_counts <- normalized_combined_counts_no_rrna[, row.names(Th1_meta)]
  
pca_matrix <- prcomp(t(Th1_norm_counts))$x
df <- cbind(Th1_meta, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")
```

#### Cell type: DN
```{r no rrna_PCA_combined_DN}
DN_meta <- subset(combined_metadata, celltype == "DN")
DN_norm_counts <- normalized_combined_counts_no_rrna[, row.names(DN_meta)]
  
pca_matrix <- prcomp(t(DN_norm_counts))$x
df <- cbind(DN_meta, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")
```


## Correlation (Spearman) heatmap of TMM-normalized counts (no mt genes) - by cell type
The Spearman correlation heatmap is more resistant to outliers than the Pearson heatmap (above), but again, the groups do not cluster well.

#### Cell type: DP
```{r no rrna_heatmap_combined-DP}
heatmap_fn(cor(DP_norm_counts, method="spearman"))
```

#### Cell type: Th17
```{r no rrna_heatmap_combined-DP}
heatmap_fn(cor(Th17_norm_counts, method="spearman"))
```

#### Cell type: Th1
```{r no rrna_heatmap_combined-DP}
heatmap_fn(cor(Th1_norm_counts, method="spearman"))
```

#### Cell type: DN
```{r no rrna_heatmap_combined-DP}
heatmap_fn(cor(DN_norm_counts, method="spearman"))
```

##PCA of the top 500 variant genes
```{r no rrna_top 500 variant genes-PCA_combined}
ntop <- 500
rv <- rowVars(normalized_combined_counts_no_rrna)
select <- order(rv, decreasing=TRUE)[seq_len(ntop)]
pca <- prcomp(t(normalized_combined_counts_no_rrna[select,]))
pca_cut <- pca[["x"]]
pca_cut <- pca_cut[,1:2]
df <- cbind(combined_metadata, pca_cut[,c("PC1","PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
                                                                                                                               0.3)) + ggtitle("PC1 vs PC2 :: 500 top variable genes (no rrna)")
```

##Analysis of Genes in Genelist (15 genes)
Overall, the samples cluster better in the PCA plot and heatmap.

###Analysis of Genes in Genelist (15 genes) - PCA
```{r Genelist_setup_combined}
y = DGEList(counts=combined_counts_no_rrna)
y = calcNormFactors(y)
normalized_combined_counts_no_rrna = cpm(y, normalized.lib.sizes=TRUE)
ann.norm.counts <- merge(normalized_combined_counts_no_rrna, ann.genes, by=0)
row.names(ann.norm.counts) <- ann.norm.counts$Row.names
ann.norm.counts <- ann.norm.counts[,c(2:25,50)]
ann_norm_counts_no_rrna = ann.norm.counts[!rownames(ann.norm.counts) %in% rrna_genes & !rownames(ann.norm.counts) %in% mt_genes,]

ccl3 <- subset(ann_norm_counts_no_rrna, symbol == "CCL3")
ccl4 <- subset(ann_norm_counts_no_rrna, symbol == "CCL4")
ccl5 <- subset(ann_norm_counts_no_rrna, symbol == "CCL5")
ccl6 <- subset(ann_norm_counts_no_rrna, symbol == "CSF2")
ccl7 <- subset(ann_norm_counts_no_rrna, symbol == "CXCR3")
ccl8 <- subset(ann_norm_counts_no_rrna, symbol == "EPSTI1")
ccl9 <- subset(ann_norm_counts_no_rrna, symbol == "GZMB")
ccl10 <- subset(ann_norm_counts_no_rrna, symbol == "IFNG")
ccl11<- subset(ann_norm_counts_no_rrna, symbol == "IL23R")
ccl12<- subset(ann_norm_counts_no_rrna, symbol == "STAT3")
ccl13<- subset(ann_norm_counts_no_rrna, symbol == "IL3")
ccl14<- subset(ann_norm_counts_no_rrna, symbol == "RGS2")
ccl15 <- subset(ann_norm_counts_no_rrna, symbol == "STAT1")
ccl16<- subset(ann_norm_counts_no_rrna, symbol == "STAT5A")
ccl17<- subset(ann_norm_counts_no_rrna, symbol == "TBX21")
genes <- data.frame()
genes <- rbind(ccl3, ccl4, ccl5, ccl6, ccl7, ccl8, ccl9, ccl10, ccl11, ccl12, ccl13, ccl14, ccl15, ccl16, ccl17)

row.names(genes) <- genes$symbol
genes <- genes[,1:24]
order <- c(1,2,3,4,1,2,3,4,1,2,3,4,2,1,3,4,1,2,3,4,1,2,3,4)
genes <- genes[, order(order),]

#PCA plot of 15 genes
pca_matrix <- prcomp(t(genes))$x
df <- cbind(combined_metadata, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = samplegroup), 
                                                           size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3,0.3)) + ggtitle("PC1 vs PC2 :: normalized counts (no rrna)")   
```

###Analysis of Genes in Genelist (15 genes) - Heatmap
Some clustering by disease and celltype.
```{r top15_heatmap_combined}


combined_metadata_15 <- combined_metadata
combined_metadata_15 <- cbind(combined_metadata_15, order)
combined_metadata_15 <- combined_metadata_15[order(combined_metadata_15$order,combined_metadata_15$samplegroup),]
heatmap_fn(genes, method="pearson", scale = "row", show_rownames = T,cluster_rows=F, cluster_cols=F)
write.table(genes, file ="normalized_counts_15_genes_combined.txt", quote = FALSE, sep = "\t", row.names=T)

#Raw counts table
ccl3 <- subset(combined_ann_genes, symbol == "CCL3")
ccl4 <- subset(combined_ann_genes, symbol == "CCL4")
ccl5 <- subset(combined_ann_genes, symbol == "CCL5")
ccl6 <- subset(combined_ann_genes, symbol == "CSF2")
ccl7 <- subset(combined_ann_genes, symbol == "CXCR3")
ccl8 <- subset(combined_ann_genes, symbol == "EPSTI1")
ccl9 <- subset(combined_ann_genes, symbol == "GZMB")
ccl10 <- subset(combined_ann_genes, symbol == "IFNG")
ccl11<- subset(combined_ann_genes, symbol == "IL23R")
ccl12<- subset(combined_ann_genes, symbol == "STAT3")
ccl13<- subset(combined_ann_genes, symbol == "IL3")
ccl14<- subset(combined_ann_genes, symbol == "RGS2")
ccl15 <- subset(combined_ann_genes, symbol == "STAT1")
ccl16<- subset(combined_ann_genes, symbol == "STAT5A")
ccl17<- subset(combined_ann_genes, symbol == "TBX21")
counts_15_genes <- rbind(ccl3, ccl4, ccl5, ccl6, ccl7, ccl8, ccl9, ccl10, ccl11, ccl12, ccl13, ccl14, ccl15, ccl16, ccl17)
row.names(counts_15_genes) <- counts_15_genes$symbol
counts_15_genes <- counts_15_genes[, c(1:24)]
```

# Differential Expression analysis 
Differential gene expression analysis of count data was performed using the Bioconductor R package, [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html). The count data was fit to a negative binomial model and dispersion estimates were generated using the mean values from the maximum likelikhood estimate of log2 fold changes, optimizing the Cox-Reid adjusted profile likelihood. 

Several quality metrics are assessed to ensure a good fit of the count data to the model and good identification of differentially expressed genes.

## Differential Expression analysis - Disease vs. Healthy - all celltypes
```{r de-setup_combined}
library(DESeq2)
library(vsn)
design = ~pair + celltype + disease + celltype:disease
condition = "disease"

# Differential expression design parameters
combined_metadata$celltype <- factor(combined_metadata$celltype)
combined_metadata$disease <- factor(combined_metadata$disease)
combined_metadata$pair <- factor(combined_metadata$pair)

counts <- combined_counts_no_rrna[rowSums(combined_counts_no_rrna>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=combined_metadata, design = design)
dds = DESeq(dds)

resultsNames(dds)

contrast2 <- list("diseasehealthy", "diseasepatient")
disease_contrast <- results(dds, contrast=contrast2)
summary(disease_contrast)

```

### Effect of variance stabilization
For RNA-Seq gene counts, the variance increases with the mean. To account for this variance, logarithmic transformation (log2) of normalized count values will ensure that these genes won't dominate the PCA plots. However, due to the noise associated with low count values, the general log2 transformation will worsen this noise, and low count genes will instead the PCA plots. Therefore, we need to use a transformation that will stabilize the variance across the mean for the gene counts. The plots below show the log2, rlog, and vsd transformed counts (from left to right, respectively). The rlog transformation (middle) minimizes the variance best for the low and high counts.

```{r deseq-diagnostics, results='asis'}
#For RNA-Seq raw counts, variance increases with the mean. Logarithmic transformation of normalized count values with a small pseudocount will account for large variations seen between the highest expressing genes so that these genes won't dominate the PCA plots. However, due to the strong noise among low count values due to Poisson, the general log2 transformation will amplify this noise, and show the low count genes will dominate the PCA plots. Therfore, transform to stabilize variance across the mean using rlog. For high counts, gives similar results as log2, but for low counts, values are shrunken towards the genes' average across samples.

par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds))>0)
rld <- rlog(dds)
vsd <- varianceStabilizingTransformation(dds)
rlogMat <- assay(rld)
vstMat <- assay(vsd)

#Plotting transformed counts between two samples

##Plotting log2
plot(log2(counts(dds, normalized=TRUE)[,1:2] + 1),
     pch=16, cex=0.3)
##Plotting rlog
plot(assay(rld)[,1:2],
     pch=16, cex=0.3)
##Plotting vsd
plot(assay(vsd)[,1:2],
     pch=16, cex=0.3)
```

The next plots show the standard deviation of transformed counts using log2, rlog, and vsd transformations by rank(mean) (from top to bottom, respectively). The rlog and vsd transformations minimize the standard deviation for the counts. 

```{r deseq-diagnostics_rank_mean}
#Plotting standard deviation by rank(mean)
meanSdPlot(log2(counts(dds,normalized=TRUE)[notAllZero,] + 1),
           ylim = c(0,2.5))
meanSdPlot(assay(rld[notAllZero,]), ylim = c(0,2.5))
meanSdPlot(assay(vsd[notAllZero,]), ylim = c(0,2.5))
```

### Similarity between samples
Since the rlog transformation best minimizes variance and standard deviation, we will use the rlog transformation to estimate variation between samples with Euclidean distance and PCA. 

#### Exploring similarity using heatmap of Euclidean distances
The sample groups do not cluster very well. The controls are more like each other than the KO group, but the KO group does not appear very similar, likely due to the animals being of different sexes.

```{r sample_variation_heatmap}
sampleDists <- dist( t( assay(rld) ) )
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( rld$disease, rld$pair, sep="-" )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

#### Exploring similarity using principal component analysis
Similar to the heatmap, the controls cluster nicely, but the KO samples vary greatly on PC1, which is likely due to the different sexes of the animals in this sample group. The sample groups, KO and control, do separate nicely on the PC2 axis.

```{r sample_variation_pca}
data <- plotPCA(rld, intgroup = "disease", returnData=TRUE)
percentVar <- round(100 * attr(data, "percentVar"))

ggplot(data, aes(PC1, PC2, color=disease)) + geom_point(size=8) +
        xlab(paste0("PC1: ",percentVar[1],"% variance")) +
        ylab(paste0("PC2: ",percentVar[2],"% variance"))
```

### Dispersion estimates
The following plot shows the dispersion by mean of normalized counts. The dispersion looks good, since we expect the dispersion to decrease with increased mean of normalized counts. 

```{r dispersion-estimate}
plotDispEsts(dds)
```

### MA-plots
MA plots explore the mean expression level of the genes with the fold change, allowing visualization of the genes that are differentially expressed (red). The differentially expressed genes are identified for medium and highly- expressed genes, which is good. We would not want to see all of our differentially-expressed genes to have low expression levels.

```{r DESeq-output, results='asis'}
#res <- results(dds, alpha=.05)
plotMA(disease_contrast, ylim=c(-5,5))
```
### Volcano-plot
The following volcano plot visualizes the significant DE genes. Due to the variation in the data within the DP group, we are unable to detect any significant differential expression between healthy and diseased patients in DP cells. Significance threshold is alpha < 0.05, which would show up as points greater than -log10 padj value of 1.3. The lowest padj value for genes is 0.381, which is far from the cut-off value.

```{r DESeq-volcano}

df <- data.frame(disease_contrast)
# ggplot(data=df, aes(x=log2FoldChange, y=-log10(padj))) +
#   scale_color_manual(values = c("grey", "purple")) +
#   xlim(c(-2,2)) +
#   ylim(c(0,1.3)) +
#   geom_point(alpha=0.75, pch=16) +
#   theme(legend.position = "none",
#         plot.title = element_text(size = rel(1.5)),
#         axis.title = element_text(size = rel(1.5)),
#         axis.text = element_text(size = rel(1.25))) +
#   xlab("log2 fold change") + ylab("-log10 p-value")

with(disease_contrast, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-3,3), ylim=c(0,8)))

# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(disease_contrast, padj<.05 ), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
with(subset(disease_contrast, padj<.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="green"))
```

### Differentially expressed genes

#### Significant differentially expressed genes
Using an padj cut-off of 0.05 (p-values multiple test corrected using the BH method), 82 genes were identified as significant. The expression changes listed below for all analyses describe differences in the Sox6 KO mice relative to the control mice.

```{r results_table_all}
table(disease_contrast$padj < .05)
#Changing p-adj threshold to 0.05
resSig <- subset(disease_contrast, padj < .05)
```

#### Down-regulated genes in KO vs. Ctrl
Of the 82 differentially-expressed genes, 31 genes are significantly down-regulated in KO versus control.
```{r results_table_down}
table(resSig$log2FoldChange < 0 & resSig$padj < .05)
```

#### Up-regulated genes in KO vs. Ctrl
Of the 82 differentially-expressed genes, 51 genes are significantly up-regulated in KO versus control.
```{r results_table_up}
table(resSig$log2FoldChange > 0 & resSig$padj < .05)
#summary(res)
```

#### Significantly differentially expressed genes - expression patterns
This plot shows the expression of the significant differentially expressed genes by sample. These genes cluster nicely by sample group, without too much variation within sample group. The scale values compare the sample expression of a specific gene to the mean expression of the gene across all samples.

```{r sig_genes-heatmap}
#significant results padj < 0.05
DEG <- data.frame(baseMean = resSig[[1]], log2FoldChange = resSig[[2]], lfcSE = resSig[[3]], stat = resSig[[4]], pvalue = resSig[[5]], padj = resSig[[6]], row.names = row.names(resSig))
DEG <- cbind(DEG, name = row.names(DEG))
DEG_names <- row.names(DEG)
sig_norm_counts <- as.data.frame(combined_all_counts[DEG_names,])

get_heatmap_fn = function(combined_metadata) {
        # return the pheatmap function with or without metadata
        if(ncol(combined_metadata) == 0) {
                return(pheatmap)
        }
        else {
                # rownames(metadata) = summarydata$Name
                heatmap_fn = function(data, ...) {
                        pheatmap(data, annotation=combined_metadata, ...)
                }
                return(heatmap_fn)
        }}
heatmap_fn = get_heatmap_fn(combined_metadata)

#Values relate to the row mean subtracted from the normalized count value for each sample value.
heatmap_fn(sig_norm_counts, method="pearson", scale = "row", show_rownames = F)
```

#### Significantly differentially expressed genes - gene list
The list of significant DE genes contains the gene expression differences in the Sox6 KO mice relative to the control mice. The row names in the table are the Ensembl gene ids, followed by the columns: the mean of the normalized counts for that gene for all samples (`baseMean`), log2 fold change (`log2FoldChange`), standard error (`lfcSE`), Wald statistic (`stat`), Wald test p-value (`pvalue`), BH adjusted p-values (`padj`), and the official gene symbol (`symbol`). 

For example, in the first row of the table for gene id ENSMUSG00000031425 (official gene symbol = Plp1), the KO mice had an expression level log2 fold change of 2.467 relative to the control mice, with an average mean expression of 4406.44 (norm. counts), and the gene was up-regulated in KO relative to control mice, since the log2FoldChange is positive.

The short list of significantly differentially expressed genes is likely due to the high variability seen between the KO mice, which is probably due to the sex of the animal.

```{r sig_genes_genelist}

#All significant results with p-values < 0.05
DEGsymbol <- which(row.names(ann.genes1) %in% row.names(DEG))
DEGsymbol <- ann.genes1[DEGsymbol,]
DEGsymbol <- cbind(DEGsymbol, name = row.names(DEGsymbol))
DEG_genenames <- merge(DEG, DEGsymbol, by="name")
row.names(DEG_genenames) <- DEG_genenames$name


#Add chromosomal location to gene list using biomart
library("biomaRt")
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
conversions = getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "chromosome_name","start_position","end_position", "description"),
mart=human)
conversions$chromosome_name <- paste(conversions$chromosome_name,  conversions$start_position, conversions$end_position, sep=':')
conversions <- conversions[,c(1,3,6)]
DEG_genenames_loc <- merge(DEG_genenames, conversions, by.x="name", by.y="ensembl_gene_id")
row.names(DEG_genenames_loc) <- DEG_genenames_loc$name
DEG_genenames_loc <- DEG_genenames_loc[, c(2:7,32:34)]
names(DEG_genenames_loc) <- c("baseMean","log2FoldChange","lfcSE", "stat","pvalue","padj","symbol","chr_coord", "gene_description")
DEG_genenames_loc <- DEG_genenames_loc[order(DEG_genenames_loc$padj),]


DEG_genenames <- DEG_genenames[, c(2:7,32)]
DEG_genenames <- DEG_genenames[order(DEG_genenames$padj),]
#write.table(DEG_genenames, "Macklis_full_genelist_padj", sep="\t", quote=F)
DEG_genenames_FC <- DEG_genenames[order(DEG_genenames$log2FoldChange),]
#write.table(DEG_genenames, "Macklis_full_genelist_FC", sep="\t", quote=F)
DEG_genenames$pvalue <- format(DEG_genenames$pvalue, scientific = TRUE)
DEG_genenames$padj <- format(DEG_genenames$padj, scientific = TRUE)
knitr::kable(DEG_genenames)
```
[Download list of differential expression analysis results for all genes](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/Macklis_full_genelist_padj)

[Download list of normalized counts for all genes](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/Macklis_normalized_counts)

#### Marker genes -- expression patterns
The candidate genes did not cluster well by sample group. However, the individual genes, Fyn, Cd9, Sox6 did cluster by samplegroup.

```{r marker_gene_heatmap}
genes <- data.frame(baseMean = res[[1]], log2FoldChange = res[[2]], lfcSE = res[[3]], stat = res[[4]], pvalue = res[[5]], padj = res[[6]], row.names = row.names(res))
genes <- cbind(genes, name = row.names(genes))
genessymbol <- which(row.names(ann_gene_counts1) %in% row.names(genes))
genessymbol <- ann_gene_counts1[genessymbol,]
genessymbol <- cbind(genessymbol, name = row.names(genessymbol))
genes_genenames <- merge(genes, genessymbol, by="name")
row.names(genes_genenames) <- genes_genenames$name
genes_genenames <- genes_genenames[, c(2:7,12)]
tcf7l2 <- genes_genenames[which(genes_genenames$symbol=="Tcf7l2"),]
Casr <- genes_genenames[which(genes_genenames$symbol=="Casr"),]
Parvb <- genes_genenames[which(genes_genenames$symbol=="Parvb"),]
Apc <- genes_genenames[which(genes_genenames$symbol=="Apc"),]
Fyn <- genes_genenames[which(genes_genenames$symbol=="Fyn"),]
Cd9 <- genes_genenames[which(genes_genenames$symbol=="Cd9"),]
Nkx22 <- genes_genenames[which(genes_genenames$symbol=="Nkx2-2"),]
Sox6 <- genes_genenames[which(genes_genenames$symbol=="Sox6"),]
marker_genes <- rbind(tcf7l2, Casr, Parvb, Apc, Fyn, Cd9, Nkx22, Sox6)

marker_counts <- as.data.frame(normalized_counts[row.names(marker_genes),])
row.names(marker_counts) <- marker_genes$symbol

#Values relate to the row mean subtracted from the normalized count value for each sample value.
heatmap_fn(marker_counts, method="pearson", scale = "row", show_rownames = T)
```

#### Marker genes -- results table and counts
Among the candidate genes, only the gene Cd9 was significantly differentially expressed (down-regulated) between KO and control animals. However, due to the high variation between the KO animals and the small number of replicates, it is likely that there are many differentially expressed genes that we are unable to identify. 

```{r marker_gene_table}
knitr::kable(marker_genes)
#write.table(marker_counts, "marker_gene_counts", sep="\t", quote=F)
```
[Download Marker Genes - Normalized Counts](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/marker_gene_counts)

### Functional Analysis for DE Genes
Using the DE genes, a list of statistically enriched gene ontology (GO) terms was generated using the program [gprofileR](http://biit.cs.ut.ee/gprofiler/). Due to the single significant GO term associated with the 82 DE genes, enrichment of gene ontology terms generates little information regarding affected pathways.

```{r functional_analysis}
gene_list <- DEG_genenames
gene_list <- cbind(gene_id = gene_list$symbol, gene_list)
gene_list <- gene_list[, c(1,7)]

#gprofileR
library(gProfileR)
gprofiler_results <- gprofiler(query = gene_list, organism = "hsapiens", ordered_query = F, 
                               exclude_iea = F, max_set_size = 0, correction_method = "fdr", 
                               hier_filtering = "none", domain_size = "annotated", custom_bg = "")

allterms <- gprofiler_results$term.id
GOs <- allterms[grep("GO:", allterms)]
pvals <- gprofiler_results$p.value[grep("GO:", allterms)]
GO.pval <- cbind(gprofiler_results$term.id, gprofiler_results$p.value)
GO_genes <- gprofiler_results[, c("term.id", "term.name", "p.value", "term.size", "overlap.size", "intersection")]
names(GO_genes) <- c("term.id", "term.name", "p.value", "term.size", "overlap.size", "assoc.gene.ids")
write.table(GO_genes, file ="GO_genes", quote = FALSE, sep = "\t", row.names=T)

runRevigo(GOs, pvals)

```
[Download GO Terms](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/GO_genes)

## Differential expression between healthy and disease patients - DP cells
The differential expression analysis is able to detect expression differences similar to the differences of marker genes between cell types. Comparison of the double-positive and double-negative cells list the marker genes (Th17 and IFNG) as significant differentially expressed genes.
```{r de-setup_combined}
contrast4 <- list("celltypeDP.diseasehealthy", "celltypeDP.diseasepatient")
celltype_DP <- results(dds, contrast=contrast4)
summary(celltype_DP)

resSig <- subset(celltype_DP, padj < 0.05)
DEG <- data.frame(baseMean = resSig[[1]], log2FoldChange = resSig[[2]], lfcSE = resSig[[3]], stat = resSig[[4]], pvalue = resSig[[5]], padj = resSig[[6]], row.names = row.names(resSig))
DEG <- cbind(DEG, name = row.names(DEG))
DEGsymbol <- which(row.names(ann.genes1) %in% row.names(DEG))
DEGsymbol <- ann.genes1[DEGsymbol,]
DEGsymbol <- cbind(DEGsymbol, name = row.names(DEGsymbol))
DEG_genenames <- merge(DEG, DEGsymbol, by="name")
row.names(DEG_genenames) <- DEG_genenames$name

#Add chromosomal location to gene list using biomart
library("biomaRt")
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
conversions = getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "chromosome_name","start_position","end_position", "description"),
mart=human)
conversions$chromosome_name <- paste(conversions$chromosome_name,  conversions$start_position, conversions$end_position, sep=':')
conversions <- conversions[,c(1,3,6)]
DEG_genenames_loc <- merge(DEG_genenames, conversions, by.x="name", by.y="ensembl_gene_id")
row.names(DEG_genenames_loc) <- DEG_genenames_loc$name
DEG_genenames_loc <- DEG_genenames_loc[, c(2:7,32:34)]
names(DEG_genenames_loc) <- c("baseMean","log2FoldChange","lfcSE", "stat","pvalue","padj","symbol","chr_coord", "gene_description")
DEG_genenames_loc <- DEG_genenames_loc[order(DEG_genenames_loc$padj),]
knitr::kable(head(DEG_genenames_loc, 20))
```

## Differential expression between cell types - DP vs. DN
The differential expression analysis is able to detect expression differences similar to the differences of marker genes between cell types. Comparison of the double-positive and double-negative cells list the marker genes (Th17 and IFNG) as significant differentially expressed genes.
```{r de-setup_combined}
contrast3 <- list("celltypeDN", "celltypeDP")
celltype_DP_DN_contrast <- results(dds, contrast=contrast3)
summary(celltype_DP_DN_contrast)

resSig <- subset(celltype_DP_DN_contrast, padj < 0.05)
DEG <- data.frame(baseMean = resSig[[1]], log2FoldChange = resSig[[2]], lfcSE = resSig[[3]], stat = resSig[[4]], pvalue = resSig[[5]], padj = resSig[[6]], row.names = row.names(resSig))
DEG <- cbind(DEG, name = row.names(DEG))
DEGsymbol <- which(row.names(ann.genes1) %in% row.names(DEG))
DEGsymbol <- ann.genes1[DEGsymbol,]
DEGsymbol <- cbind(DEGsymbol, name = row.names(DEGsymbol))
DEG_genenames <- merge(DEG, DEGsymbol, by="name")
row.names(DEG_genenames) <- DEG_genenames$name


#Add chromosomal location to gene list using biomart
library("biomaRt")
human = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="hsapiens_gene_ensembl",
host = "jul2015.archive.ensembl.org")
conversions = getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "chromosome_name","start_position","end_position", "description"),
mart=human)
conversions$chromosome_name <- paste(conversions$chromosome_name,  conversions$start_position, conversions$end_position, sep=':')
conversions <- conversions[,c(1,3,6)]
DEG_genenames_loc <- merge(DEG_genenames, conversions, by.x="name", by.y="ensembl_gene_id")
row.names(DEG_genenames_loc) <- DEG_genenames_loc$name
DEG_genenames_loc <- DEG_genenames_loc[, c(2:7,32:34)]
names(DEG_genenames_loc) <- c("baseMean","log2FoldChange","lfcSE", "stat","pvalue","padj","symbol","chr_coord", "gene_description")
DEG_genenames_loc <- DEG_genenames_loc[order(DEG_genenames_loc$padj),]
knitr::kable(head(DEG_genenames_loc, 20))
```

## Differential Expression analysis - Disease vs. Healthy subset - DP cells
```{r de-setup_combined}
library(DESeq2)
library(vsn)

design = ~ pair + disease
condition = "disease"

# Differential expression design parameters

DP_meta <- subset(combined_metadata, celltype == "DP")
DP_meta$disease <- factor(DP_meta$disease)
DP_meta$pair <- factor(DP_meta$pair)
DP_counts <- combined_counts_no_rrna[, row.names(DP_meta)]

counts <- DP_counts[rowSums(DP_counts>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=DP_meta, design = design)
dds = DESeq(dds)

contrast2 <- list("diseasehealthy", "diseasepatient")
DP <- results(dds, contrast=contrast2)
summary(DP)

resSig <- subset(DP, padj < 0.05)
DEG <- data.frame(baseMean = resSig[[1]], log2FoldChange = resSig[[2]], lfcSE = resSig[[3]], stat = resSig[[4]], pvalue = resSig[[5]], padj = resSig[[6]], row.names = row.names(resSig))
DEG <- cbind(DEG, name = row.names(DEG))
DEGsymbol <- which(row.names(ann.genes1) %in% row.names(DEG))
DEGsymbol <- ann.genes1[DEGsymbol,]
DEGsymbol <- cbind(DEGsymbol, name = row.names(DEGsymbol))
DEG_genenames_DP <- merge(DEG, DEGsymbol, by="name")

DEG_genenames_loc_DP <- merge(DEG_genenames_DP, conversions, by.x="name", by.y="ensembl_gene_id")
row.names(DEG_genenames_loc_DP) <- DEG_genenames_loc_DP$name
DEG_genenames_loc_DP <- DEG_genenames_loc_DP[, c(2:7,32:34)]
names(DEG_genenames_loc_DP) <- c("baseMean","log2FoldChange","lfcSE", "stat","pvalue","padj","symbol","chr_coord", "gene_description")
DEG_genenames_loc_DP <- DEG_genenames_loc_DP[order(DEG_genenames_loc_DP$padj),]
knitr::kable(head(DEG_genenames_loc_DP, 20))
```

## Differential Expression analysis - Disease vs. Healthy - Th17 cells
```{r de-setup_combined}
library(DESeq2)
library(vsn)
design = ~ pair + pair*disease + disease
condition = "disease"

# Differential expression design parameters

Th17_meta <- subset(combined_metadata, celltype == "Th17")
Th17_meta$disease <- factor(Th17_meta$disease)
Th17_meta$pair <- factor(Th17_meta$pair)
Th17_counts <- combined_counts_no_rrna[, row.names(Th17_meta)]

counts <- Th17_counts[rowSums(Th17_counts>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=DP_meta, design = design)
dds = DESeq(dds)

contrast2 <- list("diseasehealthy", "diseasepatient")
disease_contrast <- results(dds, contrast=contrast2)
summary(disease_contrast)
```

## Differential Expression analysis - Disease vs. Healthy - Th1 cells
```{r de-setup_combined}
library(DESeq2)
library(vsn)
design = ~ pair + pair*disease + disease
condition = "disease"

# Differential expression design parameters

Th1_meta <- subset(combined_metadata, celltype == "Th1")
Th1_meta$disease <- factor(Th1_meta$disease)
Th1_meta$pair <- factor(Th1_meta$pair)
Th1_counts <- combined_counts_no_rrna[, row.names(Th1_meta)]

counts <- Th1_counts[rowSums(Th1_counts>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=DP_meta, design = design)
dds = DESeq(dds)

contrast2 <- list("diseasehealthy", "diseasepatient")
disease_contrast <- results(dds, contrast=contrast2)
summary(disease_contrast)
```

## Differential Expression analysis - Disease vs. Healthy - DN cells
```{r de-setup_combined}
library(DESeq2)
library(vsn)
design = ~ pair + pair*disease + disease
condition = "disease"

# Differential expression design parameters

DN_meta <- subset(combined_metadata, celltype == "DN")
DN_meta$disease <- factor(DN_meta$disease)
DN_meta$pair <- factor(DN_meta$pair)
DN_counts <- combined_counts_no_rrna[, row.names(DN_meta)]

counts <- DN_counts[rowSums(DN_counts>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=DP_meta, design = design)
dds = DESeq(dds)

contrast2 <- list("diseasehealthy", "diseasepatient")
disease_contrast <- results(dds, contrast=contrast2)
summary(disease_contrast)
```

# EdgeR Differential Expression Analysis

## Differential Expression analysis - Disease vs. Healthy - DP cells
```{r EdgeR_analysis}
library(edgeR)
#Create meta and count data for DP cell type
DP_meta <- subset(combined_metadata, celltype == "DP")
DP_meta$disease <- factor(DP_meta$disease)
DP_meta$pair <- factor(DP_meta$pair)
DP_counts <- combined_counts_no_rrna[, row.names(DP_meta)]

#Create DGEList object for differential expression
y <- DGEList(counts=DP_counts, group=DP_meta$disease)

#Filter out genes with rowSums of cpm > 1 and filter out genes with only one sample with expression (recommended by EdgeR guide)
keep <- rowSums(cpm(y)>1) >= 2
y <- y[keep, , keep.lib.sizes=FALSE]

#Create design matrix, accounting for matched design 
pair <- factor(DP_meta$pair)
disease <- factor(DP_meta$disease)
design <- model.matrix(~pair+disease)
#design
#Normalize counts by total count
y <- calcNormFactors(y)
#y$samples

#Estimate dispersion of counts fit to a negative binomial model
y <- estimateDisp(y, design, robust= T)
plotBCV(y)
y$common.dispersion

#Testing for differential expression using the generalized linear model (GLM) likelihood ratio test
fit <- glmFit(y, design)
lrt <- glmLRT(fit)
colnames(design)
lrt.patientvshealthy <- glmLRT(fit, coef=4)
topTags(lrt.patientvshealthy)

o <- order(lrt.patientvshealthy$table$PValue)
cpm(y)[o[1:10],]
```

## Differential Expression analysis - Disease vs. Healthy - Th17 cells
```{r EdgeR_analysis}
library(edgeR)
#Create meta and count data for Th17 cell type
Th17_meta <- subset(combined_metadata, celltype == "Th17")
Th17_meta$disease <- factor(Th17_meta$disease)
Th17_meta$pair <- factor(Th17_meta$pair)
Th17_counts <- combined_counts_no_rrna[, row.names(Th17_meta)]

#Create DGEList object for differential expression
y <- DGEList(counts=Th17_counts, group=Th17_meta$disease)

#Filter out genes with rowSums of cpm > 1 and filter out genes with only one sample with expression (recommended by EdgeR guide)
keep <- rowSums(cpm(y)>1) >= 2
y <- y[keep, , keep.lib.sizes=FALSE]

#Create design matrix, accounting for matched design 
pair <- factor(Th17_meta$pair)
disease <- factor(Th17_meta$disease)
design <- model.matrix(~pair+disease)
#design
#Normalize counts by total count
y <- calcNormFactors(y)
#y$samples

#Estimate dispersion of counts fit to a negative binomial model
y <- estimateDisp(y, design, robust= T)
plotBCV(y)
y$common.dispersion

#Testing for differential expression using the generalized linear model (GLM) likelihood ratio test
fit <- glmFit(y, design)
lrt <- glmLRT(fit)
colnames(design)
lrt.patientvshealthy <- glmLRT(fit, coef=4)
topTags(lrt.patientvshealthy)

o <- order(lrt.patientvshealthy$table$PValue)
cpm(y)[o[1:10],]
```

## Differential Expression analysis - Disease vs. Healthy - Th1 cells
```{r EdgeR_analysis}
library(edgeR)
#Create meta and count data for Th1 cell type
Th1_meta <- subset(combined_metadata, celltype == "Th1")
Th1_meta$disease <- factor(Th1_meta$disease)
Th1_meta$pair <- factor(Th1_meta$pair)
Th1_counts <- combined_counts_no_rrna[, row.names(Th1_meta)]

#Create DGEList object for differential expression
y <- DGEList(counts=Th1_counts, group=Th1_meta$disease)

#Filter out genes with rowSums of cpm > 1 and filter out genes with only one sample with expression (recommended by EdgeR guide)
keep <- rowSums(cpm(y)>1) >= 2
y <- y[keep, , keep.lib.sizes=FALSE]

#Create design matrix, accounting for matched design 
pair <- factor(Th1_meta$pair)
disease <- factor(Th1_meta$disease)
design <- model.matrix(~pair+disease)
#design
#Normalize counts by total count
y <- calcNormFactors(y)
#y$samples

#Estimate dispersion of counts fit to a negative binomial model
y <- estimateDisp(y, design, robust= T)
plotBCV(y)
y$common.dispersion

#Testing for differential expression using the generalized linear model (GLM) likelihood ratio test
fit <- glmFit(y, design)
lrt <- glmLRT(fit)
colnames(design)
lrt.patientvshealthy <- glmLRT(fit, coef=4)
topTags(lrt.patientvshealthy)

o <- order(lrt.patientvshealthy$table$PValue)
cpm(y)[o[1:10],]
```

## Differential Expression analysis - Disease vs. Healthy - DN cells
```{r EdgeR_analysis}
library(edgeR)
#Create meta and count data for DN cell type
DN_meta <- subset(combined_metadata, celltype == "DN")
DN_meta$disease <- factor(DN_meta$disease)
DN_meta$pair <- factor(DN_meta$pair)
DN_counts <- combined_counts_no_rrna[, row.names(DN_meta)]

#Create DGEList object for differential expression
y <- DGEList(counts=DN_counts, group=DN_meta$disease)

#Filter out genes with rowSums of cpm > 1 and filter out genes with only one sample with expression (recommended by EdgeR guide)
keep <- rowSums(cpm(y)>1) >= 2
y <- y[keep, , keep.lib.sizes=FALSE]

#Create design matrix, accounting for matched design 
pair <- factor(DN_meta$pair)
disease <- factor(DN_meta$disease)
design <- model.matrix(~pair+disease)
#design
#Normalize counts by total count
y <- calcNormFactors(y)
#y$samples

#Estimate dispersion of counts fit to a negative binomial model
y <- estimateDisp(y, design, robust= T)
plotBCV(y)
y$common.dispersion

#Testing for differential expression using the generalized linear model (GLM) likelihood ratio test
fit <- glmFit(y, design)
lrt <- glmLRT(fit)
colnames(design)
lrt.patientvshealthy <- glmLRT(fit, coef=4)
topTags(lrt.patientvshealthy)

o <- order(lrt.patientvshealthy$table$PValue)
cpm(y)[o[1:10],]
```
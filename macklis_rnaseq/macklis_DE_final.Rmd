---
output:
  knitrBootstrap::bootstrap_document:
    theme: readable
    highlight: zenburn
    theme.chooser: TRUE
    highlight.chooser: TRUE
  html_document:
    toc: true
    highlight: zenburn
---
        
        
```{r setup0, echo=FALSE}
knitr::opts_chunk$set(tidy=TRUE, highlight=TRUE, dev="png",
                      cache=FALSE, highlight=TRUE, autodep=TRUE, warning=FALSE, error=FALSE, message=FALSE, prompt=TRUE, comment='', fig.cap='', fig.height = 9, fig.width = 12, bootstrap.show.code=FALSE)
```

```{r projsetup, echo=FALSE, warning=FALSE, message=FALSE}
project="Macklis RNA-seq - combined runs"
clientname="Hari Padmanabhan"
clientemail="hari_padmanabhan@harvard.edu"
labPI="Jeffrey Macklis"
analystname="Mary Piper and Lorena Pantano"
analystemail="piper@hsph.harvard.edu and lpantano@hsph.harvard.edu"
```

---

# Macklis Differential Gene Expression Report

Client: `r clientname`, `r labPI` group.

Analysts: `r analystname` (`r analystemail`)

The most recent update of this html document occurred: `r date()`

---
        
# Overview
Differential expression report for RNA-Seq on Sox6 heterozygous and KO oligodendrocyte samples isolated from the cortex of age-matched neonatal mouse brains.   

```{r qc-setup_combined}
library(ggplot2)
library(reshape)
library(gplots)
library(edgeR)
library(CHBUtils)
library(pheatmap)
library(RColorBrewer)
library(knitr)
library(tidyr)
library(reshape)
library(rmarkdown)
library(dplyr)
library(ggdendro)
library(grid)
library(reshape)
library(gridExtra)
library(Biobase)
library(scales)
library(DESeq2)
library(gProfileR)

#Merge all data for separate data points for each sample from each run
project_summary3 = "~/Dropbox/HBC consults/2015_11_24_macklis/run3/2015-12-02_macklis-rnaseq3/project-summary3.csv"
counts3_file = "~/Dropbox/HBC consults/2015_11_24_macklis/run3/2015-12-02_macklis-rnaseq3/combined.counts"
project_summary2 = "~/Dropbox/HBC consults/2015_11_24_macklis/run2/2015-12-01_macklis-rnaseq/project-summary-run2.csv"
counts2_file = "~/Dropbox/HBC consults/2015_11_24_macklis/run2/2015-12-01_macklis-rnaseq/combined.counts"
project_summary1 = "~/Dropbox/HBC consults/2015_11_24_macklis/run1/2015-11-26_macklis-rnaseq_unst_run1/project-summary_unst_run1.csv"
counts1_file = "~/Dropbox/HBC consults/2015_11_24_macklis/run1/2015-11-26_macklis-rnaseq_unst_run1/combined.counts"
ann_genes1 <- "~/Dropbox/HBC consults/2015_11_24_macklis/run1/2015-11-26_macklis-rnaseq_unst_run1/annotated_combined.counts"
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
               "#0072B2", "#D55E00", "#CC79A7")
#Run 3
summarydata3 = data.frame(read.table(project_summary3, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata3$Name = rownames(summarydata3)
summarydata3 = summarydata3[order(summarydata3$Name),]
counts3 = read.table(counts3_file, header=TRUE, row.names="id", check.names=FALSE)
counts3 = counts3[, order(colnames(counts3))]
colnames(counts3) = gsub(".counts", "", colnames(counts3))
total_counts3 <- colSums(counts3, na.rm = FALSE, dims = 1)

## this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality",
                  "rRNA_rate", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
metadata3<- summarydata3[,c(25,26,27)]
metadata3<-metadata3[,c(1,3)]

#Run 2
summarydata2 = data.frame(read.table(project_summary2, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata2$Name = rownames(summarydata2)
summarydata2 = summarydata2[order(summarydata2$Name),]
counts2 = read.table(counts2_file, header=TRUE, row.names="id", check.names=FALSE)
counts2 = counts2[, order(colnames(counts2))]
colnames(counts2) = gsub(".counts", "", colnames(counts2))
total_counts2 <- colSums(counts2, na.rm = FALSE, dims = 1)

## this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality",
                  "rRNA_rate", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
metadata2<- summarydata2[,c(25,26,27)]
metadata2<-metadata2[,c(1,3)]

#Run 1
summarydata1 = data.frame(read.table(project_summary1, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata1$Name = rownames(summarydata1)
summarydata1 = summarydata1[order(summarydata1$Name),]
counts1 = read.table(counts1_file, header=TRUE, row.names="id", check.names=FALSE)
counts1 = counts1[, order(colnames(counts1))]
colnames(counts1) = gsub(".counts", "", colnames(counts1))
total_counts1 <- colSums(counts1, na.rm = FALSE, dims = 1)
ann_gene_counts1 <- read.table(ann_genes1, header=T, row.names = "id", check.names=F)
## this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality",
                  "rRNA_rate", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
metadata1<- summarydata1[,c(25,26,27)]
metadata1<-metadata1[,c(1,3)]

#Merge all runs
summarydata_merge <- rbind(summarydata1, summarydata2, summarydata3)
counts_merge <- cbind(counts1, counts2, counts3)
metadata_merge <- rbind(metadata1, metadata2, metadata3)

#Combine data for a single sample datapoint for all runs
project_summary3 = "~/Dropbox/HBC consults/2015_11_24_macklis/run3/2015-12-02_macklis-rnaseq3/project-summary3.csv"
counts3_file = "~/Dropbox/HBC consults/2015_11_24_macklis/run3/2015-12-02_macklis-rnaseq3/combined.counts"
project_summary2 = "~/Dropbox/HBC consults/2015_11_24_macklis/run2/2015-12-01_macklis-rnaseq/project-summary-run2.csv"
counts2_file = "~/Dropbox/HBC consults/2015_11_24_macklis/run2/2015-12-01_macklis-rnaseq/combined.counts"
project_summary1 = "~/Dropbox/HBC consults/2015_11_24_macklis/run1/2015-11-26_macklis-rnaseq_unst_run1/project-summary_unst_run1.csv"
counts1_file = "~/Dropbox/HBC consults/2015_11_24_macklis/run1/2015-11-26_macklis-rnaseq_unst_run1/combined.counts"
ann_genes1 <- "~/Dropbox/HBC consults/2015_11_24_macklis/run1/2015-11-26_macklis-rnaseq_unst_run1/annotated_combined.counts"
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442",
               "#0072B2", "#D55E00", "#CC79A7")
#Run 3
summarydata3 = data.frame(read.table(project_summary3, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata3$Name = rownames(summarydata3)
summarydata3 = summarydata3[order(summarydata3$Name),]
counts3 = read.table(counts3_file, header=TRUE, row.names="id", check.names=FALSE)
counts3 = counts3[, order(colnames(counts3))]
colnames(counts3) = gsub(".counts", "", colnames(counts3))
total_counts3 <- colSums(counts3, na.rm = FALSE, dims = 1)

## this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality",
                  "rRNA_rate", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
metadata3<- summarydata3[,c(25,26,27)]
metadata3<-metadata3[,c(1,3)]

#Run 2
summarydata2 = data.frame(read.table(project_summary2, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata2$Name = rownames(summarydata2)
summarydata2 = summarydata2[order(summarydata2$Name),]
counts2 = read.table(counts2_file, header=TRUE, row.names="id", check.names=FALSE)
counts2 = counts2[, order(colnames(counts2))]
colnames(counts2) = gsub(".counts", "", colnames(counts2))
total_counts2 <- colSums(counts2, na.rm = FALSE, dims = 1)

## this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality",
                  "rRNA_rate", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
metadata2<- summarydata2[,c(25,26,27)]
metadata2<-metadata2[,c(1,3)]

#Run 1
summarydata1 = data.frame(read.table(project_summary1, header=TRUE, sep=","), row.names="Name", check.rows=FALSE)
summarydata1$Name = rownames(summarydata1)
summarydata1 = summarydata1[order(summarydata1$Name),]
counts1 = read.table(counts1_file, header=TRUE, row.names="id", check.names=FALSE)
counts1 = counts1[, order(colnames(counts1))]
colnames(counts1) = gsub(".counts", "", colnames(counts1))
total_counts1 <- colSums(counts1, na.rm = FALSE, dims = 1)
ann_gene_counts1 <- read.table(ann_genes1, header=T, row.names = "id", check.names=F)
## this is a list of all non user-supplied metadata columns that could appear
known_columns = c("Name", "X.GC", "Exonic.Rate", "Sequences.flagged.as.poor.quality",
                  "rRNA_rate", "Fragment.Length.Mean", "Intronic.Rate", "Intergenic.Rate",
                  "Mapping.Rate", "Quality.format", "Duplication.Rate.of.Mapped", "Mapped",
                  "rRNA", "Sequence.length", "Transcripts.Detected", "Mean.Per.Base.Cov.",
                  "Genes.Detected", "Unique.Starts.Per.Read", "unique_starts_per_read",
                  "complexity", "X5.3.bias")
metadata1<- summarydata1[,c(25,26,27)]
metadata1<-metadata1[,c(1,3)]

#Combine data all runs
counts_combined <- counts1 + counts2 + counts3
names(counts_combined) <- c("BC1", "BC2", "BC3", "BC4")
metadata_combined <- metadata1
row.names(metadata_combined) <- c("BC1", "BC2", "BC3", "BC4")
metadata_combined <- metadata_combined[1]
```

# Quality control metrics - separately by run
```{r heatmap-function_separate}
get_heatmap_fn = function(summarydata_merge) {
        # return the pheatmap function with or without metadata
        if(ncol(metadata_merge) == 0) {
                return(pheatmap)
        }
        else {
                # rownames(metadata) = summarydata$Name
                heatmap_fn = function(data, ...) {
                        pheatmap(data, annotation=metadata_merge, ...)
                }
                return(heatmap_fn)
        }}
heatmap_fn = get_heatmap_fn(summarydata_merge)
```

The samples for each of the individual sequencing runs are shown in the following plots, using the nomenclature "samplename_run#". For example, "BC1_2" refers to sample "BC1", run 2.

We use the following quality control metrics to assess the quality of the samples and identify outliers and to determine whether we see any strong batch effects. If we do not see any strong batch effects, then we will combine all runs for each sample for the differential expression analysis.

## Total reads
The total reads are the number of input reads for each sample. The number of reads for each sample is similar between samples for each run, which is good. We start with ~5 million reads for runs 1 and 2, and >20 million reads for run3. 20 million reads is low for general RNA-Seq analyses, but quite good for low input RNA-Seq.

```{r table_qc_metrics}
path_results = "~/Dropbox/HBC consults/2015_11_24_macklis/"
qc = read.table(file.path(path_results, "metrics_merge.tsv"),
                header=T, sep="\t", check.names=F,
                colClasses=list("sample"="character"))
rownames(qc) = qc$sample
qc$Mapped_reads_pct = as.numeric(gsub("%", "", qc$Mapped_reads_pct))
qc$Duplicates_pct = as.numeric(gsub("%", "", qc$Duplicates_pct))
qc$samplegroup <- metadata_merge$samplegroup

metrics = c("sample", "Total_reads" ,"Mapped_reads_pct", "Duplicates_pct",
            "offtarget", "%GC", "Sequence_length", "Median_insert_size")
```

## Total reads
```{r total-reads}
ggplot(qc, aes(x=sample, y=Total_reads/1e6, fill=samplegroup)) +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        geom_bar(stat = 'identity') +
        ylab("Million reads")
```

## Mapped reads
Most of the reads mapped with ~5 million reads mapping for runs 1 and 2, and >20 million for run3.

```{r mapped-plot}
ggplot(summarydata_merge, aes(x=Name, y=Mapped, fill=samplegroup)) +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        geom_bar(stat="identity") +
        ylab("mapped reads") + xlab("")
```

## Genomic mapping rate
The mapping rate is very good, with ~90% of reads mapping to the genome. Also, good is that there are similar mapping rates for all samples, and no obvious outliers.

```{r mapping-rate-plot}
ggplot(summarydata_merge, aes(x=Name, y=Mapping.Rate, fill=samplegroup)) +
        geom_bar(stat="identity") +
        ylab("mapping rate") + xlab("") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90))
```

## Number of genes detected
The number of genes detected for each sample is good for the number of input reads. Over 15,000 genes are detected for runs 1 and 2, and ~18,000 genes detected for run3. The greater number of genes detected for run3 is to be expected based on the greater depth of sequencing for this run.

```{r genes-detected-plot}
dd <- data.frame(Name=names(counts_merge), Genes.Detected = colSums(counts_merge > 0))
dd$samplegroup <- metadata_merge$samplegroup
ggplot(dd, aes(x=Name, y=Genes.Detected, fill=samplegroup)) +
        geom_bar(stat="identity") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        ylab("genes detected") + xlab("")
```

## Gene detection saturation
Gene detection saturation was not reached for samples in this experiment. The greater number of reads mapped, the greater the number of genes detected.

```{r saturation-plot}
dd = data.frame(Mapped=summarydata_merge$Mapped, Genes.Detected = colSums(counts_merge > 0))
ggplot(dd, aes(x=Mapped, y=Genes.Detected)) +
        geom_point() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        ylab("genes detected") + xlab("reads mapped")
```

## Exonic mapping rate
While generally exonic mapping rates for RNA-Seq analyses should be ~70%, the method used for cDNA generation and library preparation from low input RNA is expected to yield much lower exonic mapping rates ~40%. Therefore, the ~50% exonic mapping rates are quite good. Slightly higher exonic mapping rates for KO samples, but still quite similar to Ctrl samples.

```{r exonic-mapping-plot}
ggplot(summarydata_merge, aes(x=Name, y=Exonic.Rate, fill=samplegroup)) +
        geom_bar(stat="identity") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        ylab("exonic mapping rate") + xlab("")
```

## rRNA mapping rate
Very low rates of rRNA mapping, which is good.

```{r rRNA-rate-plot}
ggplot(summarydata_merge, aes(x=Name, y=rRNA_rate, fill=samplegroup)) +
        geom_bar(stat="identity") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        ylab("rRNA rate") + xlab("")
```

## Estimated fragment length of paired-end reads
Generally we expect the fragment length to be similar for all samples. Since we see similar fragment length for all of the run3 samples, it is likely an artifact of the small number of reads mapped from runs 1 and 2.

```{r fragment-length-plot}
ggplot(summarydata_merge, aes(x=Name, y=Fragment.Length.Mean, fill=samplegroup)) +
        geom_bar(stat="identity") +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) +
        ylab("fragment length") + xlab("")
```

## Boxplot of log10 counts per gene
Generally, we expect similar count spreads for all genes between samples unless the library sizes are different. Since the run3 library was much bigger, we see an increased number of counts on average and a larger spread, which is to be expected.

```{r boxplot-raw_separate}
melted = melt(counts_merge)
colnames(melted) = c("sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) + xlab("")
```

## Boxplot of log10 TMM-normalized counts per gene
Trimmed mean of M-values (TMM) normalization is described
[here](http://genomebiology.com/2010/11/3/R25)

Robinson, M. D., & Oshlack, A. (2010). A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology, 11(3). doi:10.1186/gb-2010-11-3-r25

Similar to the previous plot, only normalized for library size. Now distributions of counts per gene appear similar between samples. The larger spread for the run3 samples is likely due to the ability to detect some additional low expressing genes.

```{r boxplot-normalized_separate}
y = DGEList(counts=counts_merge)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
melted = melt(normalized_counts)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) + xlab("")
```

## Density of log10 TMM-normalized counts
Generally, the density of log10 TMM-normalized counts should be similar for all samples based on the genes detected. Generally, each run yields similar densities between samples, which is good. No obvious outliers. Again, run3 is able to detect more low expressing genes, so there is a slight shift in the lower part of the curve for run3.

```{r density-normalized_separate}
ggplot(melted, aes(x=count, group=sample)) +
        geom_density() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) + xlab("")
```

## Correlation (Pearson) heatmap of TMM-normalized counts
The samples cluster well across runs.

```{r pearson-heatmap-normalized_separate}
heatmap_fn(cor(normalized_counts, method="pearson"))
```

## Correlation (Spearman) heatmap of TMM-normalized counts
The Spearman correlation heatmap is more resistant to outliers than the Pearson heatmap (above), and again, the samples cluster well across runs.

```{r spearman-heatmap-normalized_separate}
heatmap_fn(cor(normalized_counts, method="spearman"))
```

## PCA plot of TMM-normalized counts
Principal components analysis is a multivariate technique that allows us to summarize the systematic patterns of variations in the data. PCA takes the expression levels for genes and transforms it in principal component space, reducing each sample into one point. Thereby, we can separate samples by expression variation, and identify potential sample outliers. The PCA plot is another way to look at how samples are clustering. 

In this PCA plot the different sequencing runs for the same samples cluster well, so we should be able to combine the counts for each run together for the differential expression analysis. The Control and Knockout groups do not cluster together, perhaps due to the mice in the KO group being of different sex. The lack of clustering in the KO group may suggest a problem for identifying differentially expressed genes. Potentially, there could be too great of variation within group compared to variation between groups to identify many differentially expressed genes. As the groups are confounded by sex (KO's have females while controls don't), differentially expressed genes may also only reflect the difference in sex between the groups.

```{r pca_separate}
## MDS plot of TMM-normalized counts
# mds(normalized_counts, k=length(colnames(normalized_counts)) - 1)
metadata = subset(metadata_merge, select= c(samplegroup,Name))

pca_matrix <- prcomp(t(normalized_counts))$x
df <- cbind(metadata, pca_matrix[, c("PC1", "PC2")])

ggplot(df, aes(PC1, PC2, color = samplegroup)) + geom_text(aes(PC1, PC2, label = Name), 
    size = 5, hjust = 0.1, vjust = 0.1) + scale_x_continuous(expand = c(0.3, 
    0.3)) + ggtitle("PC1 vs PC2 :: normalized counts")

## Heatmap of top 30 most expressed genes
#select = order(rowMeans(counts_merge),decreasing=TRUE)[1:30]
#heatmap_fn(counts_merge[select,])
```

## Heatmap by concordance correlation coefficient
http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004075

```{r propcor-heatmap_separate}
propcor = function(x, y) {
        x = log(x + 0.1)
        y = log(y + 0.1)
        num = 2 * cov(x, y)
        denom = var(x) + var(y)
        return(num/denom)}

do_propcor = function(x) {
        mat = list()
        for(i in seq_len(ncol(x))) {
                for(j in seq_len(ncol(x))) {
                        x2 = x[, i]
                        y2 = x[, j]
                        mat = c(mat, propcor(x2, y2)) } }
        mat = unlist(mat)
        mat = matrix(mat, ncol(x), ncol(x))
        colnames(mat) = colnames(x)
        rownames(mat) = colnames(x)
        return(mat)}

heatmap_fn(do_propcor(normalized_counts))
```

## Top variant genes
The plot below identifies the top most variant genes and examines their expression between samples. The single most variant gene is Xist, which is only expressed in female animals. Many of the remaining top variant genes also vary greatly between the female and male mice in the KO group. In addition to the PCA plot, this data indicates the strong effect of the sex of the animals on gene expression.
```{r de-setup_separate}
library(DESeq2)
library(vsn)
design = ~ batch + samplegroup
condition = "samplegroup"

# Differential expression design parameters
metadata_merge$batch <- c(1,1,1,1,2,2,2,2,3,3,3,3)
metadata_merge$batch <- as.factor(metadata_merge$batch)
counts <- counts_merge[rowSums(counts_merge>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=metadata_merge, design = design)
dds = DESeq(dds)

#For RNA-Seq raw counts, variance increases with the mean. Logarithmic transformation of normalized count values with a small pseudocount will account for large variations seen between the highest expressing genes so that these genes won't dominate the PCA plots. However, due to the strong noise among low count values due to Poisson, the general log2 transformation will amplify this noise, and show the low count genes will dominate the PCA plots. Therfore, transform to stabilize variance across the mean using rlog. For high counts, gives similar results as log2, but for low counts, values are shrunken towards the genes' average across samples.

par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds))>0)
rld <- rlog(dds)
vsd <- varianceStabilizingTransformation(dds)
rlogMat <- assay(rld)
vstMat <- assay(vsd)


 get_groups <- function(d, comp, condition)
 {
         g <- unlist(strsplit(comp," "))
         g1 <- d$Name[d[, (names(d)==condition)]==g[1]]
         g2 <- d$Name[d[, (names(d)==condition)]==g[3]]
         list(g1,g2)
 }


### Top variant genes

library("genefilter")
topVarGenes <- head(order(rowVars(assay(rld)),decreasing=TRUE),20)
mat <- assay(rld)[ topVarGenes, ]
mat <- mat - rowMeans(mat)
df <- as.data.frame(colData(rld)[,c("samplegroup", "batch")])
pheatmap(mat, annotation_col=df)
```


# Quality control metrics - combined runs
Since the same samples from all three runs clustered well and exhibited similar QC metrics, we combined the same samples from each run into a single sample for differential expression analysis. To ensure the QC metrics still look good, we examined some of the same QC metrics for the combined samples.

```{r heatmap-function_combined}
get_heatmap_fn = function(metadata_combined) {
        # return the pheatmap function with or without metadata
        if(ncol(metadata_combined) == 0) {
                return(pheatmap)
        }
        else {
                # rownames(metadata) = summarydata$Name
                heatmap_fn = function(data, ...) {
                        pheatmap(data, annotation=metadata_combined, ...)
                }
                return(heatmap_fn)
        }}
heatmap_fn = get_heatmap_fn(metadata_combined)
```

## Boxplot of log10 counts per gene
Generally, we expect similar count spreads for all genes between samples unless the library sizes are different. Very similar counts spreads observed for all samples.

```{r boxplot-raw_combined}
melted = melt(counts_combined)
colnames(melted) = c("sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) + xlab("")
```

## Boxplot of log10 TMM-normalized counts per gene
Trimmed mean of M-values (TMM) normalization is described
[here](http://genomebiology.com/2010/11/3/R25)

Robinson, M. D., & Oshlack, A. (2010). A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology, 11(3). doi:10.1186/gb-2010-11-3-r25

```{r boxplot-normalized_combined}
y = DGEList(counts=counts_combined)
y = calcNormFactors(y)
normalized_counts = cpm(y, normalized.lib.sizes=TRUE)
melted = melt(normalized_counts)
colnames(melted) = c("gene", "sample", "count")
melted$sample = factor(melted$sample)
melted = melted[order(melted$sample),]
melted$count = log(melted$count)
ggplot(melted, aes(x=sample, y=count)) + geom_boxplot() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) + xlab("")
#write.table(normalized_counts, "Macklis_normalized_counts", sep="\t", quote=F)
```

## Density of log10 TMM-normalized counts
Generally, the density of log10 TMM-normalized counts should be similar for all samples based on the genes detected. Generally, each combined sample yields similar density curves, which is good. No obvious outliers.

```{r density-normalized_combined}
ggplot(melted, aes(x=count, group=sample)) +
        geom_density() +
        theme_bw(base_size=10) +
        theme(panel.grid.major = element_line(size = .5, color = "grey"),
              axis.text.x = element_text(angle=90)) + xlab("")
```

## Correlation (Pearson) heatmap of TMM-normalized counts
The Ctrl samples cluster well, but the KO samples do not.

```{r pearson-heatmap-normalized_combined}
heatmap_fn(cor(normalized_counts, method="pearson"))
```

## Correlation (Spearman) heatmap of TMM-normalized counts
The Spearman correlation heatmap is more resistant to outliers than the Pearson heatmap (above), but we do not see the groups cluster as well. It is not surprising that we see the KO samples not cluster by group due to the differences in gene expression related to the sex of animals. 

```{r spearman-heatmap-normalized_combined}
heatmap_fn(cor(normalized_counts, method="spearman"))
```

# Differential expression analysis - combined runs
Differential gene expression analysis of count data was performed using the Bioconductor R package, [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html). The count data was fit to a negative binomial model and dispersion estimates were generated using the mean values from the maximum likelikhood estimate of log2 fold changes, optimizing the Cox-Reid adjusted profile likelihood. 

Several quality metrics are assessed to ensure a good fit of the count data to the model and good identification of differentially expressed genes.

```{r de-setup_combined}
library(DESeq2)
library(vsn)
design = ~ samplegroup
condition = "samplegroup"

# Differential expression design parameters
counts <- counts_combined[rowSums(counts_combined>0)>1,]
dds = DESeqDataSetFromMatrix(countData=counts,
                             colData=metadata_combined, design = design)
dds = DESeq(dds)
```

## Effect of variance stabilization
For RNA-Seq gene counts, the variance increases with the mean. To account for this variance, logarithmic transformation (log2) of normalized count values will ensure that these genes won't dominate the PCA plots. However, due to the noise associated with low count values, the general log2 transformation will worsen this noise, and low count genes will instead dominate the PCA plots. Therefore, we need to use a transformation that will stabilize the variance across the mean for the gene counts. The plots below show the log2, rlog, and vsd transformed counts (from left to right, respectively). The rlog transformation (middle) minimizes the variance best for the low and high counts.

```{r deseq-diagnostics, results='asis'}
#For RNA-Seq raw counts, variance increases with the mean. Logarithmic transformation of normalized count values with a small pseudocount will account for large variations seen between the highest expressing genes so that these genes won't dominate the PCA plots. However, due to the strong noise among low count values due to Poisson, the general log2 transformation will amplify this noise, and show the low count genes will dominate the PCA plots. Therfore, transform to stabilize variance across the mean using rlog. For high counts, gives similar results as log2, but for low counts, values are shrunken towards the genes' average across samples.

par(mfrow=c(1,3))
notAllZero <- (rowSums(counts(dds))>0)
rld <- rlog(dds)
vsd <- varianceStabilizingTransformation(dds)
rlogMat <- assay(rld)
vstMat <- assay(vsd)

```

The next plots show the standard deviation of transformed counts using log2, rlog, and vsd transformations by rank(mean) (from top to bottom, respectively). The rlog and vsd transformations minimize the standard deviation for the counts. 

```{r deseq-diagnostics_rank_mean}
#Plotting standard deviation by rank(mean)
meanSdPlot(log2(counts(dds,normalized=TRUE)[notAllZero,] + 1),
           ylim = c(0,2.5))
meanSdPlot(assay(rld[notAllZero,]), ylim = c(0,2.5))
meanSdPlot(assay(vsd[notAllZero,]), ylim = c(0,2.5))
```

##Similarity between samples
Since the rlog transformation best minimizes variance and standard deviation, we will use the rlog transformation to estimate variation between samples with Euclidean distance and PCA. 

###Exploring similarity using heatmap of Euclidean distances
The sample groups do not cluster very well. The controls are more like each other than the KO group, but the KO group does not appear very similar, likely due to the animals being of different sexes.

```{r sample_variation_heatmap}
sampleDists <- dist( t( assay(rld) ) )
sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( rld$samplegroup, rld$batch, sep="-" )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)
```

###Exploring similarity using principal component analysis
Similar to the heatmap, the controls cluster nicely, but the KO samples vary greatly on PC1, which is likely due to the different sexes of the animals in this sample group. The sample groups, KO and control, do separate nicely on the PC2 axis.

```{r sample_variation_pca}
data <- plotPCA(rld, intgroup = "samplegroup", returnData=TRUE)
percentVar <- round(100 * attr(data, "percentVar"))

ggplot(data, aes(PC1, PC2, color=samplegroup)) + geom_point(size=8) +
        xlab(paste0("PC1: ",percentVar[1],"% variance")) +
        ylab(paste0("PC2: ",percentVar[2],"% variance"))
```

## Dispersion estimates
The following plot shows the dispersion by mean of normalized counts. The dispersion looks good, since we expect the dispersion to decrease with increased mean of normalized counts. 

```{r dispersion-estimate}
plotDispEsts(dds)
```

```{r deseq2-handler}
res <- results(dds, alpha=.05)
handle_deseq2 = function(dds, metadata_combined, column) {
        all_combs = combn(levels(metadata_combined[,column]), 2, simplify=FALSE)
        all_results = list()
        contrast_strings = list()
        for(comb in all_combs) {
                contrast_string = paste(comb, collapse=" vs ")
                contrast = c(column, comb)
                res = results(dds, contrast=contrast)
                res = res[order(res$padj),]
                all_results = c(all_results, res)
                contrast_strings = c(contrast_strings, contrast_string)
        }
        names(all_results) = contrast_strings
        return(all_results)
}
```

## MA-plots
MA plots explore the mean expression level of the genes with the fold change, allowing visualization of the genes that are differentially expressed (red). The differentially expressed genes are identified for medium and highly- expressed genes, which is good. We would not want to see all of our differentially-expressed genes to have low expression levels.

```{r DESeq-output, results='asis'}

all_results = handle_deseq2(dds, summarydata_merge, condition)
len = length(all_results)
nr = ceiling( len / 3 )
nc = ceiling( len / nr )
par(mfrow=c(nr,nc))
for(i in seq(length(all_results))) {
        plotMA(all_results[[i]])
        title(paste("MA plot for contrast", names(all_results)[i]))
}

plotMA(res, ylim=c(-2,3))
```

## Volcano-plots
The following volcano plot visualizes the significant DE genes (threshold padj = 0.05) in red relative to the genes not significantly differentially expressed (in black). The significant genes with log2 fold changes > 1 are displayed in green. This plot indicates that most of the significant genes with large fold changes (logFC > 1) between conditions are significant at our designated threshold, which is good. 

```{r DESeq-volcano}
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-2,2), ylim=c(0,40)))

# Add colored points: red if padj<0.05, orange of log2FC>1, green if both)
with(subset(res, padj<.05 ), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
with(subset(res, abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="orange"))
with(subset(res, padj<.05 & abs(log2FoldChange)>1), points(log2FoldChange, -log10(pvalue), pch=20, col="green"))

```

## Differentially expressed genes

### Significant differentially expressed genes
Using an padj cut-off of 0.05 (p-values multiple test corrected using the BH method), 82 genes were identified as significant. The expression changes listed below for all analyses describe differences in the Sox6 KO mice relative to the control mice.

```{r results_table_all}
res <- results(dds, alpha=.05)
#Changing p-adj threshold to 0.05
res.05 <- results(dds, alpha=.05)
table(res.05$padj < .05)
```

### Down-regulated genes in KO vs. Ctrl
Of the 82 differentially-expressed genes, 31 genes are significantly down-regulated in KO versus control.
```{r results_table_down}
table(res.05$log2FoldChange < 0 & res.05$padj < .05)
```

### Up-regulated genes in KO vs. Ctrl
Of the 82 differentially-expressed genes, 51 genes are significantly up-regulated in KO versus control.
```{r results_table_up}
table(res.05$log2FoldChange > 0 & res.05$padj < .05)
#summary(res)
```

### Significantly differentially expressed genes - expression patterns
This plot shows the expression of the significant differentially expressed genes by sample. These genes cluster nicely by sample group, without too much variation within sample group. The scale values compare the sample expression of a specific gene to the mean expression of the gene across all samples.

```{r sig_genes-heatmap}
#significant results padj < 0.05
resSig <- subset(res, padj < 0.05)
DEG <- data.frame(baseMean = resSig[[1]], log2FoldChange = resSig[[2]], lfcSE = resSig[[3]], stat = resSig[[4]], pvalue = resSig[[5]], padj = resSig[[6]], row.names = row.names(resSig))
DEG <- cbind(DEG, name = row.names(DEG))
DEG_names <- row.names(DEG)
sig_norm_counts <- as.data.frame(normalized_counts[DEG_names,])

get_heatmap_fn = function(metadata_combined) {
        # return the pheatmap function with or without metadata
        if(ncol(metadata_combined) == 0) {
                return(pheatmap)
        }
        else {
                # rownames(metadata) = summarydata$Name
                heatmap_fn = function(data, ...) {
                        pheatmap(data, annotation=metadata_combined, ...)
                }
                return(heatmap_fn)
        }}
heatmap_fn = get_heatmap_fn(metadata_combined)

#Values relate to the row mean subtracted from the normalized count value for each sample value.
heatmap_fn(sig_norm_counts, method="pearson", scale = "row", show_rownames = F)
```

### Significant differentially expressed genes - gene list
The list of significant DE genes contains the gene expression differences in the Sox6 KO mice relative to the control mice. The row names in the table are the Ensembl gene ids, followed by the columns: the mean of the normalized counts for that gene for all samples (`baseMean`), log2 fold change (`log2FoldChange`), standard error (`lfcSE`), Wald statistic (`stat`), Wald test p-value (`pvalue`), BH adjusted p-values (`padj`), the official gene symbol (`symbol`), and the chromosomal location of the gene (`chr_coord`). 

For example, in the first row of the table for gene id ENSMUSG00000031425 (official gene symbol = Plp1), the KO mice had an expression level log2 fold change of 2.467 relative to the control mice, with an average mean expression of 4406.44 (norm. counts), and the gene was up-regulated in KO relative to control mice, since the log2FoldChange is positive.

The short list of significantly differentially expressed genes is likely due to the high variability seen between the KO mice, which is probably due to the sex of the animal.

```{r sig_genes_genelist}

#resSig <- resSig[ order(resSig$log2FoldChange), ]

#All significant results with p-values < 0.05
DEG <- data.frame(baseMean = resSig[[1]], log2FoldChange = resSig[[2]], lfcSE = resSig[[3]], stat = resSig[[4]], pvalue = resSig[[5]], padj = resSig[[6]], row.names = row.names(resSig))
DEG <- cbind(DEG, name = row.names(DEG))
DEGsymbol <- which(row.names(ann_gene_counts1) %in% row.names(DEG))
DEGsymbol <- ann_gene_counts1[DEGsymbol,]
DEGsymbol <- cbind(DEGsymbol, name = row.names(DEGsymbol))
DEG_genenames <- merge(DEG, DEGsymbol, by="name")

#Add chromosomal location to gene list using biomart
library("biomaRt")
mouse = useMart(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="mmusculus_gene_ensembl",
host = "jul2015.archive.ensembl.org")
conversions = getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "chromosome_name","start_position","end_position", "description"),
mart=mouse)
conversions$chromosome_name <- paste(conversions$chromosome_name,  conversions$start_position, conversions$end_position, sep=':')
conversions <- conversions[,c(1,3,6)]
DEG_genenames_loc <- merge(DEG_genenames, conversions, by.x="name", by.y="ensembl_gene_id")
row.names(DEG_genenames_loc) <- DEG_genenames_loc$name
DEG_genenames_loc <- DEG_genenames_loc[, c(2:7,12:14)]
names(DEG_genenames_loc) <- c("baseMean","log2FoldChange","lfcSE", "stat","pvalue","padj","symbol","chr_coord", "gene_description")
DEG_genenames_loc <- DEG_genenames_loc[order(DEG_genenames_loc$padj),]

#write.table(DEG_genenames_loc, "Macklis_full_genelist_padj", sep="\t", quote=F)
DEG_genenames_loc_FC <- DEG_genenames_loc[order(DEG_genenames_loc$log2FoldChange),]
#write.table(DEG_genenames_loc, "Macklis_full_genelist_FC", sep="\t", quote=F)
DEG_genenames_loc$pvalue <- format(DEG_genenames_loc$pvalue, scientific = TRUE)
DEG_genenames_loc$padj <- format(DEG_genenames_loc$padj, scientific = TRUE)
knitr::kable(DEG_genenames_loc)

#normalized counts
total_norm_counts <- counts(dds, normalized=T)
total_norm_counts <- data.frame(total_norm_counts)
total_norm_counts$names <- rownames(total_norm_counts) 

mart<- useDataset("mmusculus_gene_ensembl", 
                  useMart('ENSEMBL_MART_ENSEMBL', 
                          host =  'www.ensembl.org'))
attributes <- listAttributes(mart)
filters <- listFilters(mart)

gene.names <- getBM(filters= "ensembl_gene_id", 
                    attributes= c("ensembl_gene_id", "external_gene_name"),
                    values= row.names(total_norm_counts),
                    mart= mart)

symbol <- gene.names[match(total_norm_counts$names,gene.names$ensembl_gene_id),"external_gene_name"]
total_norm_counts <- cbind(total_norm_counts, symbol)
total_norm_counts <- total_norm_counts[, c(1:4,6)]
total_norm_counts <- format(total_norm_counts, scientific = TRUE)
#write.table(total_norm_counts, "Macklis_normalized_counts", sep="\t", quote=F)

#normalized counts of sig genes
sig_norm_counts <- total_norm_counts[row.names(DEG_genenames_loc),]
#write.table(sig_norm_counts, "Macklis_sig_norm_counts", sep="\t", quote=F)
```
[Download list of differential expression analysis results for all genes](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/Macklis_full_genelist_padj)

[Download list of normalized counts for all genes](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/Macklis_normalized_counts)

## Marker genes -- expression patterns
The candidate genes did not cluster well by sample group. However, the individual genes, Fyn, Cd9, Sox6 did cluster by samplegroup.

```{r marker_gene_heatmap}
genes <- data.frame(baseMean = res[[1]], log2FoldChange = res[[2]], lfcSE = res[[3]], stat = res[[4]], pvalue = res[[5]], padj = res[[6]], row.names = row.names(res))
genes <- cbind(genes, name = row.names(genes))
genessymbol <- which(row.names(ann_gene_counts1) %in% row.names(genes))
genessymbol <- ann_gene_counts1[genessymbol,]
genessymbol <- cbind(genessymbol, name = row.names(genessymbol))
genes_genenames <- merge(genes, genessymbol, by="name")
row.names(genes_genenames) <- genes_genenames$name
genes_genenames <- genes_genenames[, c(2:7,12)]
tcf7l2 <- genes_genenames[which(genes_genenames$symbol=="Tcf7l2"),]
Casr <- genes_genenames[which(genes_genenames$symbol=="Casr"),]
Parvb <- genes_genenames[which(genes_genenames$symbol=="Parvb"),]
Apc <- genes_genenames[which(genes_genenames$symbol=="Apc"),]
Fyn <- genes_genenames[which(genes_genenames$symbol=="Fyn"),]
Cd9 <- genes_genenames[which(genes_genenames$symbol=="Cd9"),]
Nkx22 <- genes_genenames[which(genes_genenames$symbol=="Nkx2-2"),]
Sox6 <- genes_genenames[which(genes_genenames$symbol=="Sox6"),]
marker_genes <- rbind(tcf7l2, Casr, Parvb, Apc, Fyn, Cd9, Nkx22, Sox6)

marker_counts <- as.data.frame(total_norm_counts[row.names(marker_genes),])
heatmap_marker <- marker_counts
row.names(heatmap_marker) <- marker_counts$symbol
heatmap_marker <- heatmap_marker[,1:4]

#Values relate to the row mean subtracted from the normalized count value for each sample value.
heatmap_fn(heatmap_marker, method="pearson", scale = "row", show_rownames = T)
```

## Marker genes -- results table and counts
Among the candidate genes, only the gene Cd9 was significantly differentially expressed (down-regulated) between KO and control animals. However, due to the high variation between the KO animals and the small number of replicates, it is likely that there are many differentially expressed genes that we are unable to identify. 

```{r marker_gene_table}
knitr::kable(marker_genes)
#write.table(marker_counts, "marker_gene_counts", sep="\t", quote=F)
```
[Download Marker Genes - Normalized Counts](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/marker_gene_counts)

# Functional Analysis for DE Genes
Using the DE genes, a list of statistically enriched gene ontology (GO) terms was generated using the program [gprofileR](http://biit.cs.ut.ee/gprofiler/). From the single significant GO term associated with the 82 DE genes, we can see that enrichment of gene ontology terms generates little information regarding affected pathways.

```{r functional_analysis}
gene_list <- DEG_genenames
gene_list <- cbind(gene_id = gene_list$symbol, gene_list)
gene_list <- gene_list[, c(1,7)]

#gprofileR

gprofiler_results <- gprofiler(query = gene_list, organism = "mmusculus", ordered_query = F, 
                               exclude_iea = F, max_set_size = 0, correction_method = "fdr", 
                               hier_filtering = "none", domain_size = "annotated", custom_bg = "")

allterms <- gprofiler_results$term.id
GOs <- allterms[grep("GO:", allterms)]
pvals <- gprofiler_results$p.value[grep("GO:", allterms)]
GO.pval <- cbind(gprofiler_results$term.id, gprofiler_results$p.value)
GO_genes <- gprofiler_results[, c("term.id", "term.name", "p.value", "term.size", "overlap.size", "intersection")]
names(GO_genes) <- c("term.id", "term.name", "p.value", "term.size", "overlap.size", "assoc.gene.ids")
#write.table(GO_genes, file ="GO_genes", quote = FALSE, sep = "\t", row.names=T)

#runRevigo(GOs, pvals)

```
[Download GO Terms](https://dl.dropboxusercontent.com/u/204381225/macklis/DE_report/GO_genes)